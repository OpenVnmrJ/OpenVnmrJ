/* smap2D.c */
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* smap2D.c: 2D Sensitivity Maps                                             */
/*                                                                           */
/* Copyright (C) 2012 Paul Kinchesh                                          */
/*                                                                           */
/* This file is part of Xrecon.                                              */
/*                                                                           */
/* Xrecon is free software: you can redistribute it and/or modify            */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation, either version 3 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* Xrecon is distributed in the hope that it will be useful,                 */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with Xrecon. If not, see <http://www.gnu.org/licenses/>.            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/**/

#include "../Xrecon.h"

/*
   Sensitivity maps are generated by dividing the reference images
   from each coil by either:
   (a) a separately aquired reference image with identical contrast from
       a single volume coil - Pruessmann 1999 MRM 42, 952
   (b) a single coil's reference image, or some combination of the array
       coil images
       NB the square root of the sum of squares of all the array coil images
          combination often used for phased arrays (following introduced by
          Roemer 1990 MRM 16, 192) increasingly overestimates signal intensity
          in the final image as the signal intensity decreases
          Bydder 2002 MRM 47,539 discuss and show that:
          (1) reduced bias is obtained using a single coils's reference image
          (2) local noise can be reduced when coils do not all have the same
              level of noise
*/

void smap2D(struct data *d,int mode)
{
  struct file fsref,fref;
  struct data sref,ref;
  int OK;

  /* Return if data is not from multiple receivers */
  if (d->nr<2) {
#ifdef DEBUG
  fprintf(stdout,"\n%s: %s()\n",__FILE__,__FUNCTION__);
  fprintf(stdout,"  Data is only from a single receiver\n");
  fprintf(stdout,"  Aborting recon of %s ...\n",d->file);
#endif
    return;
  }

  /* Check if a suitable reference file is defined according to mode */
  switch(mode) {
    case SM:
      /* Check if a suitable sense reference file is defined */
      /* If it is then we will use the appropriate reference data */
      if (strlen(*sval("senseref",&d->p)) > 0) { /* Sense reference defined */
        setreffile(&fsref,d,"senseref"); /* Set reference file */
        getpars(fsref.procpar[0],&sref); /* Get pars from reference procpar */
        opendata(fsref.fid[0],&sref);    /* Open reference data file fid */
        OK=checksenseref(d,&sref);       /* Check against folded parameters */
        if (!OK) return;                 /* If all is not OK bail out */
        setdatapars(&sref);              /* Set data structure parameters */
        copypar("file",&d->p,&sref.p);   /* Copy file parameter to reference data */
        copymaskpars(d,&sref);           /* Copy masking parameters to reference data */
        copysmappars(d,&sref);           /* Copy sensitivity map parameters to reference data */
        copysensepars(d,&sref);          /* Copy sense parameters to reference data */
        copynblocks(d,&sref);            /* Copy nblocks parameter to reference data */
        setref2Dmatrix(&sref,d);         /* Set reference fn and fn1 */
        d=&sref;
      }
      break;
    default:
      break;
  } /* end mode switch */

  setnvols(d);            /* Set the number of data volumes */
  dimorder2D(d);          /* Sort ascending slice and phase order */

  /* Output will be masked so we need to figure how */
  /* If we are using volume coil data we will mask with that */
  if (spar(d,"smapref","vcoil")) {   /* Volume coil reference */
    OK=setvcoil2D(d,&ref,&fref); /* Set up volume coil data parameters */
    if (!OK) return;             /* If all is not OK bail out */

    /* Loop over data blocks */
    for (d->block=0;d->block<d->nblocks;d->block++) {
      OK=smap2Dvcoil(d,&ref,mode); /* Calculate sensitivity map using volume coil reference */
      if (!OK) return;        /* If all is not OK bail out */
      w2Dfdfs(d,SM,FLT32,0);  /* Write 2D sensitivity maps from volume 0 */
      clear2Ddata(&ref);      /* Clear data from memory */
      clear2Dmask(&ref);      /* Clear mask from memory */
      clear2Ddata(d);         /* Clear data from memory */
    }
    closedata(&ref);        /* Close fid file */
    clear2Dall(&ref);       /* Clear Vcoil data */
    clear2Dall(d);          /* Clear data */

  } else { /* Not volume coil reference */

    /* Loop over data blocks */
    for (d->block=0;d->block<d->nblocks;d->block++) {
      OK=smap2Dacoil(d,mode); /* Calculate sensitivity map using array coil reference */
      if (!OK) return;        /* If all is not OK bail out */
      w2Dfdfs(d,SM,FLT32,0);  /* Write 2D sensitivity maps from volume 0 */
      clear2Ddata(d);         /* Clear data from memory */
      clear2Dmask(d);         /* Clear mask from memory */
    }
    clear2Dall(d);          /* Clear data */

  }

}

int smap2Dvcoil(struct data *d,struct data *ref,int mode)
{
  struct data d1;

  nulldata(&d1);           /* Null d1 struct */
  ref->block=d->block;     /* Set reference processing block */
  getblock2D(ref,0,NDCC);  /* Get block without applying dbh.lvl and dbh.tlt */
  shiftdata2D(ref,STD);    /* Shift FID data for fft */
  phaseramp2D(ref,PHASE);  /* Phase ramp the data to correct for phase encode offset ppe */

  if (!spar(d,"smapmask","calculated")) { /* Not pre-calculated mask */
    copy2Ddata(ref,&d1);   /* Store a copy of unweighted data */
    weightdata2D(ref,MK);  /* Apply mask weighting to data */
    zerofill2D(ref,STD);   /* Zero fill data according to fn, fn1 */
    fft2D(ref,STD);        /* 2D fft */
    shiftdata2D(ref,STD);  /* Shift data to get images */
    get2Dmask(ref,SM);     /* Get mask */
    fill2Dmask(ref,SM);    /* Density filter the mask */
    copy2Ddata(&d1,ref);   /* Restore unweighted data */
    switch(mode) {         /* Output according to mode */
      case SM:
        weightdata2D(ref,STD); /* Apply standard weighting to data */
        zerofill2D(ref,STD);   /* Zero fill data according to fn, fn1 */
        fft2D(ref,STD);        /* 2D fft */
        shiftdata2D(ref,STD);  /* Shift data to get images */
        w2Dfdfs(ref,VJ,FLT32,0);  /* Write 2D fdf image data from volume j */
        w2Dfdfs(ref,MK,FLT32,0);  /* Write 2D fdf image data from volume j */
        w2Dfdfs(ref,RMK,FLT32,0); /* Write 2D fdf image data from volume j */
        copy2Ddata(&d1,ref);   /* Restore unweighted data */
        break;
      default:
        break;
    } /* end mode switch */
    clear2Ddata(&d1);      /* Clear d1 data */
    nulldata(&d1);         /* Null d1 struct */
  }

  weightdata2D(ref,SM);    /* Apply sensitivity map weighting to data */
  zerofill2D(ref,STD);     /* Zero fill data according to fn, fn1 */
  fft2D(ref,STD);          /* 2D fft */
  shiftdata2D(ref,STD);    /* Shift data to get images */

  if (spar(d,"smapmask","calculated")) {  /* Calculated mask */
    /* Read the mask */
    if (!read2Dmask(ref,MK)) {
      fprintf(stderr,"\n%s: %s()\n",__FILE__,__FUNCTION__);
      fprintf(stderr,"  Problem reading mask\n");
      fflush(stderr);
      return(FALSE);
    }
  }

  getblock2D(d,0,NDCC);    /* Get block without applying dbh.lvl and dbh.tlt */
  shiftdata2D(d,STD);      /* Shift FID data for fft */
  zeronoise(d);            /* Zero any noise measurement */
  equalizenoise(d,SM);     /* Scale for equal noise in all receivers (smap pars) */
  phaseramp2D(d,PHASE);    /* Phase ramp the data to correct for phase encode offset ppe */
  weightdata2D(d,SM);      /* Apply sensitivity map weighting to data */
  zerofill2D(d,STD);       /* Zero fill data according to fn, fn1 */
  fft2D(d,STD);            /* 2D fft */
  shiftdata2D(d,STD);      /* Shift data to get images */
  gen2Dsmapvcoil(d,ref);   /* Generate sensitivity map using volume coil */
  mask2Ddata(d,ref);       /* Mask the data */

  return(TRUE);
}

int smap2Dacoil(struct data *d,int mode)
{
  struct data ref;

  getblock2D(d,0,NDCC);   /* Get block without applying dbh.lvl and dbh.tlt */
  shiftdata2D(d,STD);     /* Shift FID data for fft */
  equalizenoise(d,SM);    /* Scale for equal noise in all receivers  (smap pars) */
  phaseramp2D(d,PHASE);   /* Phase ramp the data to correct for phase encode offset ppe */

  if (!(spar(d,"smapmask","calculated"))) { /* Not a pre-calculated mask */
    initdata(&ref);         /* Initialize ref struct */
    copy2Ddata(d,&ref);     /* Store a copy of unweighted data */
    weightdata2D(d,MK);     /* Apply mask weighting to data */
    zerofill2D(d,STD);      /* Zero fill data according to fn, fn1 */
    fft2D(d,STD);           /* 2D fft */
    shiftdata2D(d,STD);     /* Shift data to get images */
    get2Dmask(d,SM);        /* Get mask */
    fill2Dmask(d,SM);       /* Density filter the mask */
    copy2Ddata(&ref,d);     /* Restore unweighted data */
    switch(mode) {          /* Output according to mode */
      case SM:
        weightdata2D(d,STD);    /* Apply standard weighting to data */
        zerofill2D(d,STD);      /* Zero fill data according to fn, fn1 */
        fft2D(d,STD);           /* 2D fft */
        shiftdata2D(d,STD);     /* Shift data to get images */
        w2Dfdfs(d,VJ,FLT32,0);  /* Write 2D fdf image data from volume j */
        w2Dfdfs(d,MK,FLT32,0);  /* Write 2D fdf image data from volume j */
        w2Dfdfs(d,RMK,FLT32,0); /* Write 2D fdf image data from volume j */
        copy2Ddata(&ref,d);     /* Restore unweighted data */
        break;
      default:
        break;
    } /* end mode switch */
  }

  weightdata2D(d,SM);      /* Apply sensitivity map weighting to data */
  zerofill2D(d,STD);       /* Zero fill data according to fn, fn1 */
  fft2D(d,STD);            /* 2D fft */
  shiftdata2D(d,STD);      /* Shift data to get images */

  if (spar(d,"smapmask","calculated")) { /* Calculated mask */
    /* Read the mask */
    if (!read2Dmask(d,MK)) {
      fprintf(stderr,"\n%s: %s()\n",__FILE__,__FUNCTION__);
      fprintf(stderr,"  Problem reading mask\n");
      fflush(stderr);
      return(FALSE);
    }
  }

  if (spar(d,"smapref","sos")) /* SOS reference */
    gen2Dsmapsos(d);    /* Generate sensitivity map using SOS */
  else if (spar(d,"smapref","super")) /* SUPER reference */
    /* FORCE SOS until SUPER fixed */
    gen2Dsmapsos(d);    /* Generate sensitivity map using SUPER combination */
  else
    gen2Dsmapsos(d);    /* Generate sensitivity map using SOS by default */
  mask2Ddata(d,d);
  return(TRUE);
}

int setvcoil2D(struct data *d,struct data *ref,struct file *fref)
{
  int OK;

  setreffile(fref,d,"vcoilref"); /* Set reference file */
  getpars(fref->procpar[0],ref); /* Get pars from reference procpar */
  opendata(fref->fid[0],ref);    /* Open reference data file fid */
  OK=check2Dref(d,ref);          /* Check against array coil parameters */
  if (!OK) return(FALSE);        /* if all is not OK bail out */
  setdatapars(ref);              /* Set data structure parameters */
  setnvols(ref);                 /* Set the number of data volumes */
  dimorder2D(ref);               /* Sort ascending slice and phase order */
  copymaskpars(d,ref);           /* Copy masking parameters to reference data */
  copysmappars(d,ref);           /* Copy sensitivity map parameters to reference data */
  copynblocks(d,ref);            /* Copy nblocks parameter to reference data */
  ref->fn=d->fn;                 /* Set reference fn appropriately */
  setval(&ref->p,"fn",d->fn);    /* Write fn to the reference parameter set */
  ref->fn1=d->fn1;               /* Set reference fn1 appropriately */
  setval(&ref->p,"fn1",d->fn1);  /* Write fn1 to the reference parameter set */
  return(OK);                    /* all is OK */
}

void gen2Dsmapsos(struct data *d)
{
  int dim1,dim2,dim3,nr;
  int i,j,k;
  double *dp1,*dp2;
  double re,im,*M2;

#ifdef DEBUG
  struct timeval tp;
  double t1,t2;
  int rtn;
  fprintf(stdout,"\n%s: %s()\n",__FILE__,__FUNCTION__);
  fprintf(stdout,"  Sensitivity maps using SOS method: ");
  rtn=gettimeofday(&tp, NULL);
  t1=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fflush(stdout);
#endif

  /* Data dimensions */
  dim1=d->np/2; dim2=d->nv; dim3=d->endpos-d->startpos; nr=d->nr;

  /* Allocate memory for a slice of magnitude2 data */
  if ((M2 = (double *)malloc(dim2*dim1*sizeof(double))) == NULL) nomem(__FILE__,__FUNCTION__,__LINE__);

  for (j=0;j<dim3;j++) {
    /* Set M2 to zero */
    dp1 = M2;
    for(k=0;k<dim2*dim1;k++) *dp1++ = 0.0;
    /* Fill M2 with SOS */
    for (i=0;i<nr;i++) {
      dp1 = *d->data[i][j];
      dp2 = M2;
      for(k=0;k<dim2*dim1;k++) {
        re = *dp1++;
        im = *dp1++;
        *dp2++ += re*re+im*im;
      }
    }
    /* sqrt */
    dp1 = M2;
    for(k=0;k<dim2*dim1;k++) {
      dp1[k] = sqrt(dp1[k]);
    }
    /* Now calculate sensitivity maps */
    for (i=0;i<nr;i++) {
      dp1 = *d->data[i][j];
      dp2 = M2;
      for(k=0;k<dim2*dim1;k++) {
        *dp1++ /= *dp2;
        *dp1++ /= *dp2++;
      }
    }
  }

  /* Reset max pars to default values */
  zeromax(d);

  /* Zero noise */
  zeronoise(d);

#ifdef DEBUG
  rtn=gettimeofday(&tp, NULL);
  t2=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fprintf(stdout,"took %f secs\n",t2-t1);
  fflush(stdout);
#endif

}

void gen2Dsmapsuper(struct data *d)
{
  int dim1,dim2,dim3,nr;
  int i,j,k;
  double *dp1,*dp2;

#ifdef DEBUG
  struct timeval tp;
  double t1,t2;
  int rtn;
  fprintf(stdout,"\n%s: %s()\n",__FILE__,__FUNCTION__);
  fprintf(stdout,"  Sensitivity maps using SUPER method: ");
  rtn=gettimeofday(&tp, NULL);
  t1=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fflush(stdout);
#endif

  /* Data dimensions */
  dim1=d->np/2; dim2=d->nv; dim3=d->endpos-d->startpos; nr=d->nr;

  for (j=0;j<dim3;j++) {
    /* Calculate sensitivity maps relative to 1st coil */
    for (i=1;i<nr;i++) {
      dp1 = *d->data[i][j];
      dp2 = *d->data[0][j];
      for(k=0;k<dim2*dim1*2;k++) *dp1++ /= *dp2++;
    }
/*
    for (i=1;i<nr;i++) {
      dp1 = *d->data[i][j];
      for(k=0;k<dim2*dim1*2;k++) {
        if (*dp1 > 100*mach.eps) {
          if (*dp1 > 10.0) *dp1=10.0;
          if (*dp1 < 0.1) *dp1=0.1;
        }
        else if (*dp1 < -100*mach.eps) {
          if (*dp1 < -10.0) *dp1=-10.0;
          if (*dp1 > -0.1) *dp1=-0.1;
        }
        else
          *dp1=0.0;
      }
    }
*/
    dp1 = *d->data[0][j];
    for(k=0;k<dim2*dim1*2;k++) *dp1++ = 1.0;
  }

  /* Reset max pars to default values */
  zeromax(d);

  /* Zero noise */
  zeronoise(d);

#ifdef DEBUG
  rtn=gettimeofday(&tp, NULL);
  t2=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fprintf(stdout,"took %f secs\n",t2-t1);
  fflush(stdout);
#endif

}

void gen2Dsmapvcoil(struct data *d,struct data *ref)
{
  int dim1,dim2,dim3,nr;
  int i,j,k;
  double *dp1,*dp2;
  double re,im;

#ifdef DEBUG
  struct timeval tp;
  double t1,t2;
  int rtn;
  fprintf(stdout,"\n%s: %s()\n",__FILE__,__FUNCTION__);
  fprintf(stdout,"  Sensitivity maps using volume coil reference: ");
  rtn=gettimeofday(&tp, NULL);
  t1=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fflush(stdout);
#endif

  /* Data dimensions */
  dim1=d->np/2; dim2=d->nv; dim3=d->endpos-d->startpos; nr=d->nr;

  /* Generate magnitude of the reference data */
  for (j=0;j<dim3;j++) {
    dp1 = *ref->data[0][j];
    dp2 = *ref->data[0][j];
    for(k=0;k<dim2*dim1;k++) {
      re = *dp1++;
      im = *dp1++;
      *dp2++ = sqrt(re*re+im*im);
    }
  }

  /* Calculate sensitivity maps */
  for (i=0;i<nr;i++) {
    for (j=0;j<dim3;j++) {
      dp1 = *d->data[i][j];
      dp2 = *ref->data[0][j];
      for(k=0;k<dim2*dim1;k++) {
        *dp1++ /= *dp2;
        *dp1++ /= *dp2++;
      }
    }
  }

  /* Reset max pars to default values */
  zeromax(d);

  /* Zero noise */
  zeronoise(d);

#ifdef DEBUG
  rtn=gettimeofday(&tp, NULL);
  t2=(double)tp.tv_sec+(1.e-6)*tp.tv_usec;
  fprintf(stdout,"took %f secs\n",t2-t1);
  fflush(stdout);
#endif

}
