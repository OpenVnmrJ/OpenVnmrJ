<body>
<pre>
Classes for reading, building and writing XML-based documents.
 
<h2><b>Description of key classes</b></h2>
  <i>Document Element classes</i>
  
  {@link vnmr.templates.VElement VElement}      extends ElementNode, implements MutableTreeNode
              - contains general purpose methods for insertion and deletion into 
                element trees.
              - extended classes may be used to support custom document types.

  {@link vnmr.templates.Reference Reference}     extends VElement
              - contains a filename reference to another xml file.
              - the Template file parser will expand <ref> tokens as subtrees
                when incountered in the input stream or as Reference Element 
                objects, depending on the presence and state of the Token 
                attribute "keep".
                                                   
  {@link vnmr.templates.GElement GElement}      extends VElement
              - contains a JComponent object and support methods.
              - extended classes may be used to support specific swing objects
                such as JLabel, JButton etc.

  {@link vnmr.templates.VObjElement VObjElement}   extends GElement, implements VObjIF
              - supports a GUI model that works with specific vnmrj classes
              - automatically reads and writes a specific set of attributes 
                defined as in the LayoutBuilder class constructor.   
                  
  <i>Template manager and builder classes</i>
  
  {@link vnmr.templates.Template Template}      XML manager base class
              - contains generic methods for building Element trees from
                arbitrary xml files and generating arbitrary xml files from
                Element trees.
              - Extended classes may be configured to support custom document
                types.
              - uses generic VElement objects for Element nodes

  {@link vnmr.templates.PanelTemplate PanelTemplate} extends Template
              - supports a "generic" GUI model
              - uses GElement for Element nodes
              - can be used to create and display a (JComponent) swing panel
              - supports only a DOM based GUI builder model  

  {@link vnmr.templates.LayoutBuilder LayoutBuilder}  extends PanelTemplate
              - uses and builds VObjIF JComponent classes
              - uses VElement and VObjElement Element node classes
              - constructor defines a static Hashtable of attributes that are
                automatically extracted and restored from the JComponent aspect 
                of the VObjElements that comprise the document tree. 
              - supports both DOM and static GUI builder API models 
                      
  <i>Utility classes</i>
  
  {@link vnmr.templates.ElementTree ElementTree}   contains support methods for traversing VElement trees

  {@link vnmr.templates.ExprParser ExprParser}    uses special syntax to link string segments in Attibute fields
                of adjacent element nodes.

  {@link vnmr.templates.TreePanel TreePanel}     contains support methods for JTree panels

  {@link vnmr.templates.Test Test}          creates a standalone swing window used to test package functions
              - may be used to test panels made from XML files generated using a 
                text editor.

   <h2><b>Using the {@link vnmr.templates.LayoutBuilder LayoutBuilder} class</b></h2>
   <b>DOM Document API</b>

   In this model each LayoutBuilder "user" class creates and owns a local LayoutBuilder.
   The local LayoutBuilder maintains an active XMLDocument which is modified using
   methods that build and manipulate the XMLDocument's VObjElement element tree.
   When a new VObjElement node is created using {@link vnmr.templates.Template#open(String,String) open}, {@link vnmr.templates.LayoutBuilder#newVElement(String) newVElement} etc. it automatically 
   builds the corresponding JComponent for that node. In addition, the JComponent's 
   add and remove methods are called whenever the corresponding methods in VObjElement
   are envoked. Saving the Element tree as an XML file involves a call to the the 
   XMLdocument's write function {@link vnmr.templates.Template#save(String,String) save}.
   
   <i>key features of this API model</i>
   
   1. both JComponent and VObjElement trees exist simultaneously.
   2. editing involves using methods that manipulate the Element tree (which 
      indirectly causes modifications to the JComponent tree).
   3. XML files are generated by traversing the element tree and calling the writeXML
      method at each node encountered.  

   <i>pros</i>
   
   1. DOM insures that valid XML files will be generated from valid XML input files.
   2. XMLDocument and ElementNode native or extended methods are available for traversing, 
      editing and viewing the document and element tree objects. Corresponding methods in 
      JComponent may not be available or may be more difficult to use.
   3. the DOM based API is applicable to XML based parsers and builders that do not involve
      the use and generation of JComponent trees.  
 
   <i>cons</i>
   
    1. requires more active memory since both element and JComponent trees must be 
       maintained.
    2. editing methods are more complicated since both Element and JComponent trees
       need to be modified simulaneously.
    3. interclass communication is more difficult since classes and threads remote from 
       the local LayoutBuilder user class (e.g. drag  and drop listener in TrashCan.java) 
       need to be passed a reference to the user classe's local LayoutBuilder instance.  
              
   <b>Static GUI Builder API</b>
   
   In this model LayoutBuilder user classes employ only the static {@link vnmr.templates.LayoutBuilder#build(JComponent, ButtonIF, String) build} and {@link vnmr.templates.LayoutBuilder#writeToFile(JComponent,String) writeToFile}
   methods of LayoutBuilder. The build method instantiates a temporary LayoutBuilder object
   that is used to parse an XML file and generate a JComponent tree as described above.
   The JComponent tree is added as a child node to a parent JComponent that is passed
   in to the build function. When build exits the XMlDocument and element tree go out
   of scope and will be removed from memory by Java's garbage collector. Editing involves
   manipulating the GUI tree directly using JComponent methods. Creating an XML 
   file from a JComponent tree involves calling LayoutBuilder's writeToFile method
   which traverses the JComponent tree and writes out XML formatted text for each 
   JComponent of type VObjIF encountered.

   <i>key features of this API model</i>

   1. only the JComponent tree exists in active memory.
   2. editing involves using methods that manipulate JComponent trees.
   3. XML files are generated by manually traversing a JComponent tree.  

   <i>pros</i>
   
   1. minimal active memory is required.
   2. this model may be better suited for the vnmrj GUI editor since that package 
      of classes current work only with JComponent trees .
   3. since only static methods of LayoutBuilder are used they may be accessed from
      any Java class or thread.
      
   <i>cons</i>
   
   1. not directly extendable to XML builder applications that do not use JComponent trees.
   2. DOM based methods are not available to user classes.
   3. reading and writing XML files require disconnected processes which may make the
      interface model more error prone and difficult to extend and maintain.
      
   <h2><b>Adding Attributes and Elements to the {@link vnmr.templates.LayoutBuilder LayoutBuilder} class</b></h2>

   <i>adding a new attribute type</i>
      
      1. define a new Integer attribute type in {@link vnmr.bo.VObjDef VObjDef}
        e.g.  static final int NEWATTR1 = 16;
      2. add a new entry to the {@link vnmr.templates.LayoutBuilder LayoutBuilder} class constructor
        e.g.  addAttribute("attr1", new Integer(NEWATTR1));
      
   <i>adding a new VObjIF type</i>
   
      1. define a new {@link vnmr.bo.VObjIF VObjIF} class in package vnmr.bo
        e.g. public class VWidget extends JButton implements VObjIF, VObjDef { ... }                      
      2. add a new entry to the {@link vnmr.templates.LayoutBuilder#newVObj(String) newVObj} method in LayoutBuilder
        e.g. if(type.equals("widget"))
               return new VWidget(sshare, VnmrIf, type)
</pre>
</body>

