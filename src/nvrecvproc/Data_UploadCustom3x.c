/*
 * Copyright (C) 2015  University of Oregon
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Apache License, as specified in the LICENSE file.
 *
 * For more information, see the LICENSE file.
 */
/*  WARNING!!  besure to reflect any changes to the custom deserializer back to Data_Upload.x */
/* 
 */
/* -----------------------------------------------------------------------
 * Note this file used to be generated from the Data_Upload.x file,  however
 * a custom Deserializer has been written, which is now used.
 * Note all the code is generated via a nddsgen on Data_Upload.x however
 * the original Deserializer must be commented out 
 * To allow the makefile to work this file has been put into SCCS so it can be 
 *  directly used.
 *
 *            Author:  Greg Brissey   8/26/05
 * ------------------------------------------------------------------------
 */
/**
  NDDS methods for Data_Upload type

  {\bf {\large Description}}

  This file is derived from code automatically generated by nddsgen.
  This file was automatically generated by the 'nddsgen' code generator from the
  CDR file Data_Upload.x.  See the man pages on 'nddsgen' and 'NddsCDR'.

  This file was generated with the following steps:

  One or more CDR descriptions where written into a file named 
  Data_Upload.x (NOTE: the .x termination which is standard for this 
  files is required.). This description uses the CDR language,
  which resembles "C"-like structure-type declarations. More information 
  and examples on how to write these ".x" files can be found in the 
  on-line html page for 'nddsgen'.

  'nddsgen' was run on the Data_Upload.x file. The command was:
  nddsgen -replace Data_Upload.x

  This created the Data_Upload_stubs.c, and Data_Upload.h.

  The Data_Upload_stubs.c is copied into Data_Upload.c;
  if you pass "-replace" during nddsgen. This file contains the functions, 
  NddsTypeNameSeralize(), NddsTypeNameDeserialize(), and NddsTypeNamePrint() 
  for each NDDS type.

  The user may want to fill in the code for the NddsTypeNamePrint()
  function if they want NDDS to print the NddsTypeName automatically
  in certain situations. This isn't required.

  The file Data_Upload.c also contains functions
  to register, and test NDDS types.

  @see nddsgen NddsCDR
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus

#ifndef ndds_cpp_h
#include "ndds/ndds_cpp.h"
#endif


#endif

/* #define DIAG_TIMESTAMP */
#define TS_PRT_THRESHOLD1 500000  /* 500000 */
#define TS_PRT_THRESHOLD2 5000  /* 100000 */

#include "errLogLib.h"

#ifndef RTI_NDDS_4x
#include "Data_UploadCustom3x.h"
#else /* RTI_NDDS_4x */
#include "Data_Upload.h"
#endif  /* RTI_NDDS_4x */

/* 
* Copyright (c) 1999-2000 Varian,Inc. All Rights Reserved. 
*
*/
int NddsCDRMaxSize_Data_Upload(int size)
{
    int origsize = size;
    size += NddsCDRMaxSize_long(size); /* type */
    size += NddsCDRMaxSize_long(size); /* sn */
    size += NddsCDRMaxSize_u_long(size); /* elemId */
    size += NddsCDRMaxSize_u_long(size); /* totalBytes */
    size += NddsCDRMaxSize_u_long(size); /* dataOffset */
    size += NddsCDRMaxSize_u_long(size); /* crc32chksum */
    size += NddsCDRMaxSize_long(size); /* deserializerFlag */
    size += NddsCDRMaxSize_u_long(size); /* pPrivateIssueData */
    size += NddsCDRMaxSize_sequence(size, MAX_FIXCODE_SIZE, NddsCDRMaxSize_byte(size)); /* data */
    return (size - origsize);
}


RTIBool 
NddsCDRPrint_Data_Upload(Data_Upload *objp, const char *desc, int indent)
{
    int i;
    for (i=0; i<indent; i++) { printf("  "); }
    printf("%s:\n", desc);

    if (!NddsCDRPrint_long(&objp->type, "type", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_long(&objp->sn, "sn", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_u_long(&objp->elemId, "elemId", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_u_long(&objp->totalBytes, "totalBytes", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_u_long(&objp->dataOffset, "dataOffset", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_u_long(&objp->crc32chksum, "crc32chksum", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_long(&objp->deserializerFlag, "deserializerFlag", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_u_long(&objp->pPrivateIssueData, "pPrivateIssueData", indent+1)) {
        return RTI_FALSE;
    }
    if (!NddsCDRPrint_bytes(objp->data.val, objp->data.len
                       , "data", indent+1)) {
        return RTI_FALSE;
    }
    return RTI_TRUE;
}


RTIBool NddsCDRInitialize_Data_Upload(Data_Upload *objp)
{
    if (!NddsCDRInitialize_long(&objp->type)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_long(&objp->sn)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_u_long(&objp->elemId)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_u_long(&objp->totalBytes)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_u_long(&objp->dataOffset)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_u_long(&objp->crc32chksum)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_long(&objp->deserializerFlag)){
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_u_long(&objp->pPrivateIssueData)){
        return RTI_FALSE;
    }
    objp->data.len = 0;
    if (!(objp->data.val = (char *)malloc(MAX_FIXCODE_SIZE*sizeof(char)))) {
        return RTI_FALSE;
    }
    if (!NddsCDRInitialize_chararray(objp->data.val, MAX_FIXCODE_SIZE)){
        return RTI_FALSE;
    }
    return RTI_TRUE;
}


RTIBool NddsCDRInitialize_Data_Uploadarray(Data_Upload *objp,unsigned int count)
{
    unsigned int i = 0;
    
    for(i = 0; i < count; i++){
        if(!NddsCDRInitialize_Data_Upload(&objp[i])){
            return RTI_FALSE;
        }
    }
    return RTI_TRUE;
}

RTIBool
NddsCDRSerialize_Data_Upload(NDDSCDRStream *cdrs, Data_Upload *objp)
{
    if (!NddsCDRSerialize_long(cdrs, &objp->type)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_long(cdrs, &objp->sn)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_u_long(cdrs, &objp->elemId)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_u_long(cdrs, &objp->totalBytes)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_u_long(cdrs, &objp->dataOffset)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_u_long(cdrs, &objp->crc32chksum)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_long(cdrs, &objp->deserializerFlag)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_u_long(cdrs, &objp->pPrivateIssueData)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRSerialize_bytes(cdrs, (char *)objp->data.val, (int)objp->data.len, MAX_FIXCODE_SIZE)) {
    	return (RTI_FALSE);
    }
    return (RTI_TRUE);
}

#ifdef ORIGINAL_DESERIALIZER_IS_COMMENTED_OUT_HERE

RTIBool
NddsCDRDeserialize_Data_Upload(NDDSCDRStream *cdrs, Data_Upload *objp)
{
    if (!NddsCDRDeserialize_long(cdrs, &objp->type)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_long(cdrs, &objp->sn)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->elemId)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->totalBytes)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->dataOffset)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->crc32chksum)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_long(cdrs, &objp->deserializerFlag)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->pPrivateIssueData)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_bytes(cdrs, (char *)objp->data.val, (unsigned int *)&objp->data.len, MAX_FIXCODE_SIZE)) {
    	return (RTI_FALSE);
    }
    return (RTI_TRUE);
}
#endif

#ifndef VXWORKS
 /* Direct Code from Codes_Downld.x */

static char failsafeAddr[MAX_FIXCODE_SIZE+8];

 /* Custom Deserializer routine, ifdef out auto generated one */

RTIBool
NddsCDRDeserialize_Data_Upload(NDDSCDRStream *cdrs, Data_Upload *objp)
{
    RCVR_DESC_ID pRcvrDesc;
    WORKQ_ID   pWorkQId;
    WORKQ_ENTRY_ID pWorkQEntry;
    SHARED_DATA_ID pSharedData;
    unsigned long dummy;
    int result;

    struct timeval tp;
    long usdif;

    pRcvrDesc = (RCVR_DESC_ID) objp->pPrivateIssueData;

#ifdef DIAG_TIMESTAMP
    // DPRINT(-4,"-----------------------------------------------\n"); 
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> Start1 <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD1); 
    if (usdif > TS_PRT_THRESHOLD1) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif

    if (!NddsCDRDeserialize_long(cdrs, &objp->type)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_long(cdrs, &objp->sn)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->elemId)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->totalBytes)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->dataOffset)) {
    	return (RTI_FALSE);
    }
    if (!NddsCDRDeserialize_u_long(cdrs, &objp->crc32chksum)) {
    	return (RTI_FALSE);
    }
    /* then next member used internal only and should not be deserialized */


    if (!NddsCDRDeserialize_long(cdrs, &objp->deserializerFlag)) {
    	return (RTI_FALSE);
    }

    /* if (!NddsCDRDeserialize_u_long(cdrs, &objp->pPrivateIssueData)) { */
    if (!NddsCDRDeserialize_u_long(cdrs, &dummy)) {
    	return (RTI_FALSE);
    }

    /* pRcvrDesc = (RCVR_DESC_ID) objp->pPrivateIssueData; */

#ifdef DIAG_TIMESTAMP 
    /* ~ 420 - 500 usec */
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> Member Deserial dur <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif

    result = getNewDataValPtr(objp);

#ifdef DIAG_TIMESTAMP 
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> getNewDataValPtr() duration <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif
      
      
    if (!NddsCDRDeserialize_bytes(cdrs, (char *)objp->data.val, (unsigned int *)&objp->data.len, MAX_FIXCODE_SIZE)) {
    	return (RTI_FALSE);
    }
#ifdef DESERIALIZER_DEBUG
    DPRINT3(+2,"'%s': Data_Deserializer() - transfer: to addr: 0x%lx, bytes recv: %ld\n",
			pRcvrDesc->cntlrId,objp->data.val,objp->data.len);
#endif

#ifdef DIAG_TIMESTAMP 
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> data deserial dur <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif

    pWorkQId = pRcvrDesc->pWorkQObj;
    pWorkQEntry = pRcvrDesc->activeWrkQEntry;

    objp->deserializerFlag = fillInWorkQ(objp, pWorkQEntry);

#ifdef DESERIALIZER_DEBUG
    DPRINT2(2,"'%s': Data_Deserializer() - fillInWorkQ returned: %d. \n", pRcvrDesc->cntlrId, objp->deserializerFlag);
#endif

    if ( (objp->type == DATAUPLOAD_FID) && ((objp->dataOffset+objp->data.len) == objp->totalBytes) )
    {
       objp->deserializerFlag = DATA_BLK;
#ifdef DESERIALIZER_DEBUG
       DPRINT2(-2,"'%s': Data_Deserializer() - Fid Upload Complete: flag = %d \n",
		pRcvrDesc->cntlrId,objp->deserializerFlag);
#endif
    }


#ifdef DIAG_TIMESTAMP 
    /* -------------- test output ------------------------ */
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> fillInWorkQ() dur <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif

    /* remove this lock and for aborts/errors you will coredump !! */
    pSharedData = (SHARED_DATA_ID) lockSharedData(&TheMemBarrier);
    if (pSharedData == NULL)
        errLogSysQuit(LOGOPT,debugInfo,"Deserializer: Could not lock memory barrier mutex");

      if ( pSharedData->discardIssues == 1)    /* error, start to discard any pubs receivered */
          objp->deserializerFlag = NO_DATA;

    unlockSharedData(&TheMemBarrier);
 
#ifdef DIAG_TIMESTAMP 
    /* -------------- test output ------------------------ */
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> MemBarrier dur <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif


    if ( objp->deserializerFlag == ERROR_BLK)
    {
        /* this may not be neccessary (locking), however it's know to work, so for now we keep it 1/29/07 GMB */
        /* the only reason to not use lock is to improve performance, but not worth the chance at this point */
        pSharedData = (SHARED_DATA_ID) lockSharedData(&TheMemBarrier);
        if (pSharedData == NULL)
           errLogSysQuit(LOGOPT,debugInfo,"Deserializer: Could not lock memory barrier mutex");

         pSharedData->AbortFlag = pSharedData->discardIssues = 1;   /* error, start to discard any pubs receivered */

         unlockSharedData(&TheMemBarrier);

    }

#ifdef DESERIALIZER_DEBUG
    DPRINT2(+2,"'%s': Data_Deserializer() - Finial return code: %d\n", pRcvrDesc->cntlrId, objp->deserializerFlag);
#endif


#ifdef DIAG_TIMESTAMP 
    /* -------------- test output ------------------------ */
    /* usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> Deserial dur <-",  */
    usdif = printTimeStamp(pRcvrDesc->cntlrId, "Deserialize_Data -> ErrBlk dur <-", 
                   &(pRcvrDesc->p4Diagnostics->tp),TS_PRT_THRESHOLD2); 
    if (usdif > TS_PRT_THRESHOLD2) {
         DPRINT(-4,"-----------------------------------------------\n");  }
#endif

    return (RTI_TRUE);
}
#endif

 /* Direct Code from Codes_Downld.x */
void getData_UploadInfo(NDDS_OBJ *pObj)
{
    strcpy(pObj->dataTypeName,Data_UploadNDDSType);

    pObj->TypeRegisterFunc = Data_UploadNddsRegister;
    pObj->TypeAllocFunc = (DataTypeAllocate) Data_UploadAllocate;
    pObj->TypeSizeFunc = Data_UploadMaxSize;
}


#ifndef VXWORKS

 /* 'NDDS_DataFuncs.c' line: 228, 'ddr1': Data_UpldCallBack() - VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
 * 'ddr1': Data_UpldCallBack() - Reg. FidStatBlock: elemId: 1, trueElemId: 1, FID transfer @ addr: 0xfe81003c
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe81003c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 64000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe81fa3c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 128000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe82f43c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 192000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe83ee3c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 256000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe84e83c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 320000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe85e23c, bytes recv: 64000
 * 'ddr1': Data_UpldCallBack() - offset*len: 384000, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - FID transfer: new addr: 0xfe86dc3c, bytes recv: 25600
 * 'ddr1': Data_UpldCallBack() - offset*len: 409600, totalBytes: 409600
 * 'ddr1': Data_UpldCallBack() - Fid Xfer Cmplt, Send workQEntry (0x130e1c0) to next stage
 * 'ddr1': Data_UpldCallBack() - ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 */

int getNewDataValPtr(Data_Upload *objp)
{
   RCVR_DESC_ID pRcvrDesc;
   WORKQ_ID   pWorkQId;
   WORKQ_ENTRY_ID pWorkQEntry;
   SHARED_DATA_ID pSharedData;
   int retval,workQsAv;


   pRcvrDesc = (RCVR_DESC_ID) objp->pPrivateIssueData;

   pWorkQId = pRcvrDesc->pWorkQObj;
   pWorkQEntry = pRcvrDesc->activeWrkQEntry;

   retval = 0;

   if (objp->type == DATAUPLOAD_FIDSTATBLK)
   {
#ifdef DESERIALIZER_DEBUG
         DPRINT1(+2,"'%s': getNewDataValPtr() - Statblock Transfer\n",pRcvrDesc->cntlrId);
#endif
        /* get new workQ entry and set up the issue so NDDS load data into fidstatblock buffer */
        if ( workQGetWillPend(pWorkQId) )
        {
           errLogRet(ErrLogOp,debugInfo,"'%s': getNewDataValPtr() - Going to block getting workQ\n",pRcvrDesc->cntlrId);
         }
        pRcvrDesc->activeWrkQEntry = workQGet(pWorkQId);

        objp->data.val = (char*) pRcvrDesc->activeWrkQEntry->pFidStatBlk;

#define INSTRUMENT
#ifdef INSTRUMENT

     workQsAv = numAvailWorkQs(pWorkQId);
     
     if (workQsAv < pRcvrDesc->p4Diagnostics->workQLowWaterMark)
        pRcvrDesc->p4Diagnostics->workQLowWaterMark = workQsAv;

#endif

        /* retval = 1; */
    }
    else if (objp->type == DATAUPLOAD_FID)
    {
        if (objp->dataOffset == 0)
        {
           /* objp->data.val = getWorkQNewFidBufferPtr(pWorkQId,pRcvrDesc->activeWrkQEntry); */
           objp->data.val = pRcvrDesc->activeWrkQEntry->pFidData;
           pWorkQEntry->FidStrtAddr = objp->data.val;

#ifdef DESERIALIZER_DEBUG
           DPRINT2(+2,"'%s': getNewDataValPtr() - Start of FID Transfer: start addr: 0x%lx\n",
			pRcvrDesc->cntlrId,objp->data.val);
#endif
        }
        else
        {
#ifdef DESERIALIZER_DEBUG
           DPRINT3(+2,"'%s': getNewDataValPtr() - FID: offset: %ld, totalBytes: %ld\n",
			pRcvrDesc->cntlrId,objp->dataOffset,objp->totalBytes);
#endif
           objp->data.val = (pWorkQEntry->FidStrtAddr + objp->dataOffset);
        }
   }

   pSharedData = (SHARED_DATA_ID) lockSharedData(&TheMemBarrier);
   if (pSharedData == NULL)
       errLogSysQuit(LOGOPT,debugInfo,"getNewDataValPtr: Could not lock memory barrier mutex");

     /* just incase data file not open and NULL was returned */
     if ( ( objp->data.val == NULL) || (pSharedData->discardIssues == 1) )
        objp->data.val = failsafeAddr;

    unlockSharedData(&TheMemBarrier);


   return retval;
}


int fillInWorkQ(Data_Upload *objp, WORKQ_ENTRY_ID pWorkQEntry)
{
      int retcode = 0;
      if (objp->type == DATAUPLOAD_FIDSTATBLK)
      {
         /*This is a Fid Stat Block */

        pWorkQEntry->statBlkCRC = objp->crc32chksum;

#ifdef LINUX
        FSB_CONVERT_NTOH( pWorkQEntry->pFidStatBlk );
#endif
        switch((pWorkQEntry->pFidStatBlk->doneCode & 0xFFFF))
         {
          /* any for the following case means there is no data following this statblock 
	   *	   and it should be pass on for processing 
           */
          case EXP_HALTED:
          case EXP_ABORTED:
          case HARD_ERROR:
                  pWorkQEntry->statBlkType = ERRSTATBLK;
#ifdef DESERIALIZER_DEBUG
                  DPRINT(+2,"fillInWorkQ: ERRSTATBLK\n");
#endif
                  retcode = ERROR_BLK;
                  break;

          case STOP_CMPLT:
          case SETUP_CMPLT:
          case WARNING_MSG:
                if ((pWorkQEntry->pFidStatBlk->doneCode & 0xFFFF) == WARNING_MSG)
                {
                   pWorkQEntry->statBlkType = WRNSTATBLK;
#ifdef DESERIALIZER_DEBUG
                  DPRINT(+2,"fillInWorkQ: WRNSTATBLK\n");
#endif
                }
                else
                {
                   pWorkQEntry->statBlkType = SU_STOPSTATBLK;
#ifdef DESERIALIZER_DEBUG
                  DPRINT(+2,"fillInWorkQ: SU_STOPSTATBLK\n");
#endif
                }
                 retcode = COMPLETION_BLK;
                 break;

            default:
                pWorkQEntry->statBlkType = FIDSTATBLK;
#ifdef DESERIALIZER_DEBUG
                 DPRINT(+2,"fillInWorkQ: FIDSTATBLK\n");
#endif
                retcode = NO_DATA;
                break;
         }
    }
    else if (objp->type == DATAUPLOAD_FID)
    {
        pWorkQEntry->dataCRC = objp->crc32chksum;
        retcode = NO_DATA;
    }
    return (retcode);
}
#endif
void Data_UploadAllNddsRegister()
{
    Data_UploadNddsRegister();
}
/**
  NDDS serialization method for Data_Upload

  {\bf {\large Description}}

  Required NDDS method to serialize an Data_Upload into NDDSCDRStream 
  buffer.
  The data will be deserialized by the Data_UploadDeserialize() function.

  The 'options' may be defined and used for customizing serialization
  for different situations. Often (as in this case) they are simply 
  ignored.
 
  @param nddsds A buffer to serializee the ptr parameter into.
  @param ptr    A pointer to Data_Upload to serialize.
  @param options A user 
 */

RTIBool Data_UploadSerialize(NDDSCDRStream *nddsds, Data_Upload *ptr,
                              int options)

{
    return NddsCDRSerialize_Data_Upload(nddsds, ptr);
}

/**
  NDDS Allocate method for Data_Upload objects.

  {\bf {\large Description}}

  Optional NDDS method to allocate an NDDS object of type Data_Upload.

  If registered within Data_UploadNddsRegister(), this method will be 
  invoked as a result of pattern subscriptions. When the NDDS agent 
  subscribes to a publication that matches the requested pattern, it
  needs to create a new object of the corresponding type to hold the 
  updates when they come. 
  It is for this purpose that Data_UploadAllocate() is used.

  This method is not always required because Data_UploadDeserialize()
  is usually able to allocate the object itself. There are however
  some cases (notably strings) for which the allocation provided
  by Data_UploadDeserialize() isn't sufficient. Registration
  of Data_UploadAllocate() allows to override the default allocation
  provided by Data_UploadDeserialize().

  If this method is to be used, it must passed to NddsTypeRegister()
  (in function Data_UploadNddsRegister()) instead of the default
  NULL method.

  This routine gets passed the type and name of the object instance and
  the parameter provided by the user passed in the 
  NddsSubscriptionGroupSubscriptionAdd(3) call.
 */
Data_Upload *Data_UploadAllocate()
{
    Data_Upload *ptr = NULL;

    if(!(ptr = (Data_Upload *)malloc(sizeof(Data_Upload))) ||
       !memset(ptr, 0, sizeof(Data_Upload)) ||
       !NddsCDRInitialize_Data_Upload(ptr)) {
        return NULL;
    }

    return ptr;
}

/**
  NDDS deserialization method for Data_Upload 
   
  {\bf {\large Description}}

  Required NDDS method to deserialize the data from an NDDSCDRStream buffer.
  The data was serialized by the Data_UploadSerialize() function.

  If outArray==NULL (null pointer), this function will create a
  Data_Upload of the appropriate size to hold the data 
  (as required by NDDS).

  Returns the output array or NULL if an error occurred

  @param ptr A pointer to Data_Upload to deserialize.

  @return On success, this function returns a non-NULL pointer. On failure,
          this function should return a NULL pointer.
 */
Data_Upload *Data_UploadDeserialize(NDDSCDRStream *nddsds, Data_Upload *ptr)
{
    if (!ptr &&
        !(ptr = Data_UploadAllocate())) {
        return NULL;
    }

    if (!NddsCDRDeserialize_Data_Upload(nddsds, ptr)) {
	return NULL;
    }
    
    return ptr;
}

/**
  NDDS Print method for Data_Upload objects.

  {\bf {\large Description}}

  Optional NDDS method to print the contents of an Data_Upload.

  Note that if this method *must* handle the case where the object
  is NULL.
 */
RTIBool Data_UploadPrint(Data_Upload *ptr, unsigned int indent)
{
    /* Do not remove. Data_UploadPrint must handle a NULL 
       Data_Upload 
       */
    if (!ptr) {
	printf("Data_Upload: (null)\n");
	return RTI_FALSE;
    }

    /* Replace by custom code if desired */
    if (!NddsCDRPrint_Data_Upload((Data_Upload *)ptr,"Data_Upload",indent)){
	printf("NddsCDRPrintData_Upload() failed on %p\n", ptr);
	return RTI_FALSE;
    }

    return RTI_TRUE;
}

/**
  NDDS size method for Data_Upload objects.
 
  {\bf {\large Description}}

  This optional NDDS method returns the maximum size of a Data_Upload object.
  The purpose of this method is to allow NDDS to optimize its memory usage.
 
  Users must be very careful and return a size that is equal-to or larger 
  than the maximum Data_Upload serialized. Please refer to NddsCdr(2) for
  functions to help determin the serialized size of basic types.

  If a -1 is returned then NDDS will default to a safe size, but will not
  be optimal.
 */
int Data_UploadMaxSize(int size)
{
    return NddsCDRMaxSize_Data_Upload(size);
}

/**
   NDDS Free method for Data_Upload objects.

  {\bf {\large Description}}

  Optional NDDS method to Free an NDDS object of type Data_Upload.

  This method is not used in the current version of NDDS.
 */

void Data_UploadFree(Data_Upload *inst)

{
}

/**
  Install Data_Upload type to NDDS.
   
  {\bf {\large Description}}

  This function will register an Data_Upload type with NDDS.   
  Registration must happen before any reference to the Data_Upload 
  type is given to NDDS.

  A description of the type Data_Upload was written in a file
  named Data_Upload.x (NOTE: the .x termination which is standard
  for this files is required.). This description uses the CDR language,
  which resembles "C"-like structure-type declarations. More information
  and examples on how to write these ".x" files can be found in the
  man page for 'nddsgen'.
 
  nddsgen was run on the NDDSCDRFileBaseName.x file. See the man pages
  on nddsgen and NDDSCDRFileBaseName for details.
 */
RTIBool Data_UploadNddsRegister()
{
   RTIBool returnVal =
       NddsTypeRegister(
	   Data_UploadNDDSType, /*A #define in NDDSCDRFileBaseName.h*/
	   (SerializeMethodType)Data_UploadSerialize, 
	   (DeserializeMethodType)Data_UploadDeserialize,
	   (PrintMethodType)Data_UploadPrint, 
	   (FreeMethodType)Data_UploadFree,
	   (MaxSizeMethodType)Data_UploadMaxSize);



   return returnVal;
}


