BioPack
1.0	Introduction

Biomolecular NMR experiments utilize a wide variety of macros, menus, pulse 
sequences, layouts, text files, parameter sets and other files for the execution of 
experiments, typically in H2O solutions. This manual describes the nature of these files 
for the benefit of those who wish to modify or add similar files for new experiments.

The basis of the implementation of these experiments is the reproducibility and 
predictability of the NMR console as well as the spectral nature of biologically relevant 
materials. This combination makes possible the automatic setting of power levels, pulse 
widths and shaped pulses present in modern pulse sequences. Several styles of pulse 
programming are possible, depending on the preference of the user. They all have the 
same common attribute- ease of setup and high performance.

2.0	Operation

All NMR experiments require, at a minimum, a compiled pulse program and a parameter 
set. At this level, the user must make choices of parameter values.  Shaped pulse text files 
may be required to be created, and pulse powers and pulse widths must be calibrated and 
set. Modern pulse programs may have dozens of RF pulses and gradients so that 
experiment setup in this manner may take several hours, even by expert operators.

To make the same operation just as accurate, but have the time to set up in seconds rather 
than hours, other types of files must be involved. At first, the user needs to "find" the 
experiment in a menu or other visual mode. Ideally, the user would "click" on the desired 
experiment name and the full experiment would be set up, including setting of all 
parameters. At this stage the user would only change parameter values affecting needed 
sensitivity and resolution (acquisition time in the detected dimension, number of 
increments in indirect dimension(s) and the number of transients per FID).

It is crucial that the performance of the experiment is not compromised by this automatic 
setup. This can be assured by proper pulse sequence design and the predictability of the 
spectrometer. If a user must "tweak" parameter values it is an indication of non-
reproducibility of spectrometer manufacture or non-predictability of the hardware 
performance.

This automatic mode of experiment setup is entirely governed by macros. These macros 
access a probe calibration file to retrieve parameter values and make experiment-specific 
changes. The probe file can be edited manually, but automatic calibration and probefile 
updates can be done via macros as well.

3.0	Experiment Selection

Experiments can be selected in a variety of ways. Since the process involves running a 
macro, this macro could be entered on the command line. Of course, this depends on the 
operator remembering the exact macro name (usually the name of the pulse sequence). 
These names can be long and this mode of operation has the highest error probability. 

Modern interfaces use powerful and intuitive graphical displays that can present choices 
to the operator in an obvious manner. This is often in the form of a drop-down menu. 
Other times it may be in the form of a selection of buttons. In all cases, a system text file 
that is viewable and editable by the user governs the menus or button selections.

4.0	Interface

Two major interfaces are available within released VnmrJ software: VnmrJ and "Classic 
VNMR". The latter interface was first released in 1987 and augmented with tcl/tk in the 
mid-90's. It is widely used but severely restricted in possibilities and relies on the 
operator to use command-line operation for the most part. 

VnmrJ was introduced as a modern Java-based interface to overcome the limitations of 
VNMR and offer different look-and-feel styles to different users. Based on XML files, it 
is inherently transportable across different hardware platforms. 

VNMR:
This interface consists of a command line, a fixed menu line and a variable menu line. 
The variable menu line permits the user to navigate through a menu "tree" toward the 
desired experiment. For example, if the user would like to set up a 13C-edited NOESY, 
the menu path would be:

 "Main....Setup....Proteins....Standard Experiments..... 
.....HSQCs....13C3D.....NOESYHSQC"

Clicking the NOESYHSQC button would run the gnoesyChsqc macro, resulting in a 
parameter set viewable in the text window. Tcl/tk panels present convenient displays of 
parameter information (not necessarily the parameter names) with entry boxes, check 
boxes, titles, etc., to provide ways of changing parameters or setting conditions. The tcl/tk 
display is grid-based and has a limited number of "cells" in which to place "widgets", and 
has a small number of possible panels.

The VNMR "Classic" interface does require the operator to master hundreds of 
commands and parameters to fully take advantage of the underlying software.

VnmrJ:
This interface is modern and "rich". The richness arises from the flexibility of the java 
structure and the resolution of modern displays. VnmrJ uses a variety of mechanisms to 
set up experiments. One method is to use a drop-down menu that may offer choices of 
sub-menus. Usually, only one or two sub-menus are needed to get to the desired 
experiment. Clicking on the name results in the experiment macro being run. In other 
cases, experiments are set up via a button within a "Protocol" list, or present on a panel.

When the new parameter set is installed the parameter area (layout panels) changes to 
display XML files relevant to the new experiment. Some of these files might be 
experiment-specific, others are defaults common to many other experiments. These files 
are located in /vnmr/templates/layouts or the corresponding user directory 
(~/vnmrsys/templates/layout). These files are editable or viewable. While these files are 
understandable, editing them directly is not convenient or rapid. For this, a graphical 
editor is present using "drag-and-drop" techniques for rapid user customization.

The layout panels offer methods for changing all relevant parameters (entry boxes, check 
boxes and menus). They are organized for efficient operational flow. Panels are available 
for experiment setup, acquisition, data processing, data display and plotting, and for 
archiving. In the most flexible types of panels, virtually any operation used by an expert 
operator can be made without resort to the command line. Obviously, this allows all users 
(who are expert enough in the NMR knowledge) to work from the start without spending 
a long "apprentice" phase of learning commands and parameters.

Many panels have "widgets" that initiate complex operations such as full automatic 
calibration of all RF channels and gradients, or updating the probefile with new values. 
These "widgets" are simple in themselves, only starting an appropriate macro.

VnmrJ offers a "Basic" page in the Acquire folder. This is optional and can be disabled 
by setting BPbasic=0 (or by using the checkbox in the "Globals&Probefile" page in the 
Setup folder). This panel shows buttons to automatically set up 1D, 2D or 3D 
experiments under default conditions (1ppm resolution in indirect dimensions with 8 
transients per fid). The experimental time is indicated on the message line. The 
experiment is started by a "Begin" button. There is also capability for the user to change 
nt,ni and ni2 within this panel. The resulting data should be high-performance and 
accurate assuming that the probefile is accurate for the current sample. 

5.0	Experiment Setup Macros

Since macros are the software elements that actually do the work, it is instructive to look 
in detail at the macros involved in setting up an experiment. For this, consider the 
NOESYHSQC experiment mentioned above. The menu used to select this experiment is 
present as a text file. In the "Classic" mode it is a simple ASCII menu file in 
/vnmr/menulib; in VnmrJ it is an XML submenu in /vnmr/templates/vnmj/interface for a 
/vnmr installation, or in ~/vnmrsys/templates/vnmrj/interface for a user installation. Once 
the selection is made, in either interface, the gnoesyChsqc macro is executed. The macro 
is a text file present in /vnmr/maclib and detailed in Table 1.

          Table 1.  The gnoesyChsqc macro. 

All Rights Reserved." 

BPrtppar('gnoesyChsqc')                   "sets up parameter set"

getparam('dmf30','C13'):dmf30          "gets value from probefile"
getparam('rf30','C13'):rf30
getparam('dmf80','C13'):dmf80 
getparam('rf80','C13'):rf80
getparam('gt5','N15'):gt5
getparam('gt0','N15'):gt0
getparam('gzlvl5','N15'):gzlvl5
getparam('gzlvl0','N15'):gzlvl0 
getparam('NHgstab','N15'):gstab

dof=dof-(174-35)*dfrq                  "shifts 13C offset to 35ppm"
                           /* BPsetupwurst is described in Table 10 */
BPsetwurstparams         "gets parameters for adiabatic decoupling"

if dmm<>'cccp' the       "sets parameters for non-adiabatic decoupling" 
dpwr=pwClvl-15 dmf=1e6/(2*2*1.4*pwC*compC)
 BPcheckdpwr         "readjusts conditions if above optional limit"
Endif

dm='nnny'                      "sets C13 decoupling in acquisition"
dm2='nnnn' dmm2='cccc'                 "no decoupling on channel 3"

pwC10 = 80.5*600.0/sfrq           "recalculates shaped pulse width"
$pw=pwC10*5.0 $pw=2.0*trunc($pw/2.0)+1.0 pwC10=($pw + 1.0)/5.0

spin='n' sw2=80d       "sets up 13C indirect dimension spectral width" 
ni=0  ni2=0 phase=1 phase2=1      "sets up for 1D spectral check"

Let us now examine the elements of the gnoesyChsqc macro in detail. First, a general 
parameter set recall macro BPrtppar is run (Table 2), specifying the gnoesyChsqc 
parameter set. Note that in most cases the parameter set has the same name as the pulse 
sequence. The parameter set can be present in either /vnmr/parlib or in the user's parlib, 
depending on user preference. If no user parlib entry for gnoesyChsqc.par is present, the 
/vnmr/parlib entry is used as default.

                             Table 2. The BPrtppar macro

Rights Reserved."
if $#>0.5 then             "$# is the number of arguments supplied"

 $file='' $file=$1         "$1 is the argument supplied"
 length($file):$size
 if $size>4 then
  $t=''
  substr($file,$size-3,4):$t
  if $t<>'.par' then
    $file=$file+'.par'
  endif
 else
  $file=$file+'.par'       "$file is the name of the parameter set"
 endif

 $fpath=userdir+'/parlib/'+$file
 exists($fpath,'file'):$e            "checks for presence in user file"
 if $e<0.5 then
  $fpath=systemdir+'/parlib/'+$file  "uses system file if no user file"
  exists($fpath,'file'):$f
  if $f<0.5 then
    write('error','%s: could not find \'%s\'',$0,$fpath)
    return
  endif
 endif

 "write('alpha','%s: retrieving \'%s\'',$0,$fpath)"
 rtp($fpath)                           "actual recall of parameter set"
 
if (BPinstall=1) then     "only true if the proper files are installed" 

  BPupdate_from_probefile     "gets common calibrations from probefile"


/* Refer to BPupdate_from_probefile macro description below */

  getparam('BPtemp','H1'):temp  "gets temp value used in autocalibrate"
                                "or autoupdate"

/* Refer to getparam macro description below */	

/* Note- The "exists" macro used below finds the presence or absence of 
parameters in the just-recalled parameter set */

  exists('mag_flg','parameter'):$e             
  if $e=1 then 
     getparam('mag_flg','N15'):mag_flg       "needed for xyz gradients" 
     if (mag_flg='y') then BPcheckfortriax endif
  endif



/* The BPcheckfortriax macro makes sure a gradtable is present in 
/vnmr/imaging/gradtables. The gradtable has the calibrations for the x, 
y and z gradients so that the pulse sequence statement "magradpulse" 
will work properly (used for magic-angle gradients). The probefile has 
an entry for mag_flg. A value of 'y' indicates that the user wants to 
use magic-angle gradients for those sequences in which they are 
optional */

  exists('pwHs','parameter'):$e       "used for selective H2O pw90"

"***************Experiment uses pwHs*******************************"
  if $e=1 then 
   getparam('pwHs','H1'):pwHs
   pwHs=1700*(500/sfrq)                            "scales bandwidth"
         "this line can be omitted if the probefile value is desired"
   exists('grecov','parameter'):$e       "used in rna sequences only"
   if $e then
    $shape='rna_H2Osinc'
   else
    $shape='H2Osinc'
   endif                           "now find if this shape exists"

   exists(systemdir+'/shapelib/'+$shape+'.RF','file'):$es
   if not($es) then
    exists(userdir+'/shapelib/'+$shape+'.RF','file'):$es
   endif

   if $es then
     pwsadj($shape,'pwHs')     "adjusts pwHs for multiple of 200nsec"
   endif
  endif
/*****************end of check for pwHs***********************/ 

   exists('tpwrsf','parameter'):$e
   if $e=1 then getparam('tpwrsf','H1'):tpwrsf endif

/* Make sure fine power parameters are present for possible use */	

   exists('tpwrsf_t','parameter'):$e
   if $e=0 then create('tpwrsf_t','real') tpwrsf_t=4095 endif

   exists('tpwrsf_i','parameter'):$e
   if $e=0 then create('tpwrsf_i','real') tpwrsf_i=4095 endif

   exists('tpwrsf_u','parameter'):$e
   if $e=0 then create('tpwrsf_u','real') tpwrsf_u=4095 endif

   exists('tpwrsf_d','parameter'):$e
   if $e=0 then create('tpwrsf_d','real') tpwrsf_d=4095 endif

   exists('tpwrsf_n','parameter'):$e
   if $e=0 then create('tpwrsf_n','real') tpwrsf_n=4095 endif





/* Find if user or /vnmr probefile is used */

   $probe=probe
   exists(systemdir+'/bin','file','rwx'):$e

   if $e then
    $sysadd = 1
    $probedir = systemdir + '/probes'
   else
    $sysadd = 0
    $probedir = userdir + '/probes'
   endif

   $result='' $numi=0 $numt=0 $numu=0 $numd=0 $numn=0
   $probefile = $probedir + '/' + $probe + '/' + $probe


/* Get fine power values from probefile, if present ($num*=1) */
   lookup('file',$probefile)
   lookup('seek','H1tpwrsf_i','read'):$result,$numi
   lookup('file',$probefile)
   lookup('seek','H1tpwrsf_t','read'):$result,$numt
   lookup('file',$probefile)
   lookup('seek','H1tpwrsf_u','read'):$result,$numu
   lookup('file',$probefile)
   lookup('seek','H1tpwrsf_d','read'):$result,$numd
   lookup('file',$probefile)
   lookup('seek','H1tpwrsf_n','read'):$result,$numn

/* Add probefile entry if needed ($num*=0), else get value */

   if $numi=0 then
     $tpwrsf_i='' format(tpwrsf_i,4,0):$tpwrsf_i 
     addparams('tpwrsf_i',$tpwrsf_i,'H1') 
   else
     getparam('tpwrsf_i','H1'):tpwrsf_i
   endif
   if $numt=0 then
     $tpwrsf_t='' format(tpwrsf_t,4,0):$tpwrsf_t 
     addparams('tpwrsf_t',$tpwrsf_t,'H1') 
   else
     getparam('tpwrsf_t','H1'):tpwrsf_t
   endif
   if $numu=0 then
     $tpwrsf_u='' format(tpwrsf_u,4,0):$tpwrsf_u 
     addparams('tpwrsf_u',$tpwrsf_u,'H1') 
   else
     getparam('tpwrsf_u','H1'):tpwrsf_u
   endif
   if $numd=0 then
     $tpwrsf_d='' format(tpwrsf_d,4,0):$tpwrsf_d 
     addparams('tpwrsf_d',$tpwrsf_d,'H1') 
   else
     getparam('tpwrsf_d','H1'):tpwrsf_d
   endif


   if $numn=0 then
     $tpwrsf_n='' format(tpwrsf_n,4,0):$tpwrsf_n 
     addparams('tpwrsf_n',$tpwrsf_n,'H1') 
   else
     getparam('tpwrsf_n','H1'):tpwrsf_n
   endif


  exists('pwHs2','parameter'):$e
  if $e=1 then 
   getparam('pwHs2','H1'):pwHs2
   exists('finepwrf','parameter'):$e
   if $e=1 then getparam('finepwrf','H1'):finepwrf endif
  endif
 
 /* Set up reasonable weighting function */ 

  sb=-at sbs=sb gf='n' awc='n' lb='n'


/* Set up user's desired solvent suppression filter */ 

  getparam('ssfilter','H1'):ssfilter
  getparam('ssntaps','H1'):ssntaps
  getparam('ssorder','H1'):ssorder
  getparam('sslsfrq','H1'):sslsfrq
  
/* Make sure gradient shimming parameters are present */ 
  exists('gzsize','parameter'):$e
  if $e=0 then create('gzsize','real') endif
  exists('gzwin','parameter'):$e
  if $e=0 then create('gzwin','real') endif
 

/* destroy nv parameters if they are present (for proper ft3d) */ 

  exists('nv2','parameter'):$e
  if $e then destroy('nv2') endif
  exists('nv','parameter'):$e
  if $e then destroy('nv') endif

/* Make sure powers are within user-defined limits */

  BPcheck

  endif       "end of BPinstall=1 section"
endif         "end of arguments>0 section"

r1=0 r2=0 r3=0 r4=0 r5=0 r6=0  "reset variables"
wnt='' wexp=''
pmode='full'   
sw=sw  "forces oversamp calculation"
dn='C13' "prevents 1H on channel 2 with obs 1H on channel 1"
bs='n'   "makes sure bs='n' for 2D/3D"


The BPupdate_from_probefile macro is detailed in Table 3. It serves to retrieve the 
values of commonly used parameters from the probefile. In many cases the retrieved 
parameters may not be used in the pulse sequence, but the information is useful and is 
displayed in a common format within the parameter panels. Thus, the 13C pw90 is 
always available in the "Decoupler" tcl/tk panel, or the "Channels" VnmrJ panel.

                     Table 3  The BPupdate_from_probefile macro  

"BPupdate_from_probefile  gets common parameters values from probefile"
/* Gets common acquisition parameter values */
getparam('rof1','H1'):rof1
getparam('rof2','H1'):rof2
getparam('alfa','H1'):alfa
getparam('sw','H1'):sw
getparam('at','H1'):at
getparam('BPd1','H1'):d1
getparam('BPgain','H1'):gain

/* Gets common RF parameter values */
getparam('ref_pw90','H1'):ref_pw90
getparam('ref_pwr','H1'):ref_pwr
getparam('pw90','H1'):pw
getparam('pw90','H1'):pw90
getparam('tpwr','H1'):tpwr
getparam('tofH2O','H1'):tof
getparam('compH','H1'):compH

getparam('pwC','C13'):pwC
getparam('pwClvl','C13'):pwClvl
getparam('compC','C13'):compC
getparam('dofCO','C13'):dof      "always start with dof=174ppm for 13C"

getparam('pwN','N15'):pwN
getparam('pwNlvl','N15'):pwNlvl
getparam('compN','N15'):compN
getparam('dofN15','N15'):dof2
getparam('dpwr2NH','N15'):dpwr2
getparam('dmm2NH','N15'):dmm2
getparam('dres2NH','N15'):dres2
getparam('dmf2NH','N15'):dmf2

/* Gets common gradient parameter values */
exists('gzcal','parameter'):$e
if $e then
 getparam('BPgzcal','N15'):gzcal
endif
exists('grecov','parameter'):$e
if $e then
 getparam('NHgstab','N15'):grecov
endif
exists('gstab','parameter'):$e
if $e then
 getparam('NHgstab','N15'):gstab
endif

/* Gets STUD Decoupling parameter values, if appropriate */
exists('STUD','parameter'):$e
if $e then
 exists('dmf140','parameter'):$ex
 if $ex<0.5 then 
  create('dmf140','real')
 endif
 exists('dmf80','parameter'):$ex
 if $ex<0.5 then 
  create('dmf80','real')
 endif
 exists('dmf30','parameter'):$ex
 if $ex<0.5 then 
  create('dmf30','real')
 endif
 exists('rf140','parameter'):$ex
 if $ex<0.5 then 
  create('rf140','real')
 endif
 exists('rf80','parameter'):$ex
 if $ex<0.5 then 
  create('rf80','real')
 endif
 exists('rf30','parameter'):$ex
 if $ex<0.5 then 
  create('rf30','real')
 endif
 getparam('dmf140','C13'):dmf140
 getparam('dmf80','C13'):dmf80
 getparam('dmf30','C13'):dmf30
 getparam('rf140','C13'):rf140
 getparam('rf80','C13'):rf80
 getparam('rf30','C13'):rf30
endif

Experiment setup macros and the BPrtppar macro all use the getparam macro. This macro 
is the fundamental tool for accessing the probefile. It requires the name of the parameter 
stored in the probefile, as well as the section (by nucleus) in which it is stored. The output 
of the macro is the value of the parameter that is placed in the parameter specified. A 
similar macro, addparams, is used to add a parameter to the probefile. It accepts only text 
strings so it is common to prepare a text string using the format command prior to using 
addparams. If the parameter is already present as a text string, for example dmm, the 
formatting is not necessary. 

6.0 Use of the Probefile

As indicated above, most macros involved in experiment setup retrieve parameters values 
from information stored in a probefile. This file is located in /vnmr/probes or 
~/vnmrsys/probes (the user file). Different probes directories can be stored here. While 
typically these are physically different probes, this is not required. The probefile names 
could be for different samples, for example, so that by changing probe "names" one can 
return to a desired set of conditions or calibrations. VnmrJ offers a probe popup utility in 
the hardware bar that has a menu widget showing all system or user probefiles. Just 
clicking the appropriate probefile name changes the value of "probe" in the user's 
~/vnmrsys/global. In "Classic" VNMR, the probe name can be changed directly on the 
command line.

The default name for the probefile for biomolecular experiments is "HCN". Once this 
probefile has been created (see below) the name can be changed by using a UNIX shell 
and the "mv" command to any desired name. All macros use only the name contained in 
the global variable "probe", rather than looking for a specific "HCN" file.

The probefile must be updated with calibrations appropriate for the current instrument, 
after the probefile is created. This is done first by making sure that the current parameter 
set has all the common parameters stored in the probefile (typically, this is true for the 
ghn_co.par parameter set). Therefore, to update the probefile, either use a menu button 
for "HNCO" (Classic VNMR), use the drop-down VnmrJ menu to select Triple-
Resonance/NH-Detected/HNCO, or use the macro "ghn_co" on the command line. In all 
cases the ghn_co macro is executed.

 If the biomolecular files have just been installed (the global variable BPinstall=0), menu 
buttons are provided to "activate" the files (and set BPinstall=1). These buttons run the 
macros BPbiopack1a (Table 5) or BPbiopack1b which, in turn, run BPaddprobe (Table 6) 
as part of setting up a ghn_co parameter set. These menu options allow  (a) a new 
probefile or, (b) a copy of the system probefile "HCN" to be created. 

 Once the calibrated or approximate calibrations are entered, the user must update the 
probefile using either the menu button (Classic VNMR) or the button present in the 
"Globals&Probefile" panel in the "Setup" folder. This runs the macro BPbiopack2 (Table 
7).

                        Table 4  The ghn_co macro  
 BPrtppar('ghn_co')
 BPsetampmode         "sets ampmode parameter value to match hardware"
 getparam('NHgrad1_time','N15'):gt1   "Gets parameters for ghn_co"
 getparam('NHgrad1_lvl','N15'):gzlvl1    "coherence transfer gradients"
 getparam('NHgrad2_lvl','N15'):gzlvl2 
 getparam('NHgstab','N15'):gstab
 getparam('swN','N15'):sw2                "typical 15N spectral window"
 getparam('waltzB1','H1'):waltzB1    "proton decoupling field strength"
 dm2='nny'                  "sets up for 15N decoupling in acquisition"
 
 getparam('gt5','N15'):gt5          "get values for crusher gradiensts"
 getparam('gt0','N15'):gt0
 getparam('gzlvl5','N15'):gzlvl5
 getparam('gzlvl0','N15'):gzlvl0

/* Recalculates pulse widths using same equations as used for */
/* making shapes so no timing errors are generated at "go" */

 pwC3 = 1.0e6*sqrt(3.0)/(2.0*118.0*dfrq)
 $pw = pwC3*5.0   $pw = trunc($pw + 0.5) pwC3 = $pw/5.0
 pwC3a = pwC3
 pwC4 = 1.0e6*sqrt(3.0)/(2.0*118.0*dfrq)
 $pw = pwC4*5.0   $pw =     trunc($pw + 0.5)   pwC4 = $pw/5.0
 pwC5 = 88.8*600.0/sfrq
 $pw = pwC5*5.0   $pw = 2.0*trunc($pw/2.0)+1.0 pwC5 = ($pw+1.0)/5.0
 pwC6 = 88.8*600.0/sfrq
 $pw = pwC6*5.0   $pw = 2.0*trunc($pw/2.0)+1.0 pwC6 = ($pw+1.0)/5.0
 pwC7 = 80.5*600.0/sfrq
 $pw = pwC7*5.0   $pw = 2.0*trunc($pw/2.0)+1.0 pwC7 = ($pw+1.0)/5.0
 pwC7a = pwC7
 pwC8 = 80.5*600.0/sfrq
 $pw = pwC8*5.0   $pw = 2.0*trunc($pw/2.0)+1.0 pwC8 = ($pw+1.0)/5.0
 pwC8a = pwC8
 pwC9 = 80.5*600.0/sfrq
 $pw = pwC9*5.0   $pw = 2.0*trunc($pw/2.0)+1.0 pwC9 = ($pw+1.0)/5.0
 pwC9a = pwC9
 spin='n' ni=0  ni2=0 phase=1 phase2=1
 if (numrfch>3) then         "only get 2H parameters if  >3channels"
  getparam('dof3D','H2'):dof3
  getparam('dmm3D','H2'):dmm3
  getparam('dmf3D','H2'):dmf3
  getparam('dpwr3D','H2'):dpwr3
  getparam('dres3D','H2'):dres3
  getparam('dseq3D','H2'):dseq3
 else
  exists('ampmode','parameter'):$e  "don't need ampmode if <4 channels"
  if ($e=1) then destroy('ampmode') endif
 endif
 
                        Table 5.  The BPbiopack1a macro  
/* This macro runs relevant sections of the ghn_co macro          */
/* It is used as part of the "Activate" process, driven by menu   */
/* No probefile likely exists so no getparam statements are used  */
/* It is run only once, to setup ghn_co and create the probefile  */
/* BPbiopack1a('y') is used for VnmrJ ($#<>0)                     */

BPrtppar('ghn_co') 
fn=np np=fn fn=2*np
pwC3 = 1.0e6*sqrt(3.0)/(2.0*118.0*dfrq)
$pw = pwC3*5.0      $pw = trunc($pw + 0.5)    pwC3 = $pw/5.0
pwC3a = pwC3
pwC4 = 1.0e6*sqrt(3.0)/(2.0*118.0*dfrq)
$pw = pwC4*5.0      $pw = trunc($pw + 0.5)    pwC4 = $pw/5.0
pwC5 = 88.8*600.0/sfrq
$pw = pwC5*5.0 $pw = 2.0*trunc($pw/2.0) + 1.0 pwC5 = ($pw + 1.0)/5.0
pwC6 = 88.8*600.0/sfrq
$pw = pwC6*5.0 $pw = 2.0*trunc($pw/2.0) + 1.0 pwC6 = ($pw + 1.0)/5.0
pwC7 = 80.5*600.0/sfrq
$pw = pwC7*5.0 $pw = 2.0*trunc($pw/2.0) + 1.0 pwC7 = ($pw + 1.0)/5.0
pwC7a = pwC7
pwC8 = 80.5*600.0/sfrq
$pw = pwC8*5.0 $pw = 2.0*trunc($pw/2.0) + 1.0 pwC8 = ($pw + 1.0)/5.0
pwC8a = pwC8
pwC9 = 80.5*600.0/sfrq
$pw = pwC9*5.0 $pw = 2.0*trunc($pw/2.0) + 1.0 pwC9 = ($pw + 1.0)/5.0
pwC9a = pwC9
spin='n' ni=0  ni2=0 phase=1 phase2=1

exists('waltzB1','parameter'):$e
if $e=0 then create('waltzB1','real') waltzB1=5p endif
exists('dmf30','parameter'):$e
if $e=0 then create('dmf30','real') endif
exists('rf30','parameter'):$e
if $e=0 then create('rf30','real') endif
exists('dmf80','parameter'):$e
if $e=0 then create('dmf80','real') endif
exists('rf80','parameter'):$e
if $e=0 then create('rf80','real') endif

exists('dmf140','parameter'):$e
if $e=0 then create('dmf140','real') endif
exists('rf140','parameter'):$e
if $e=0 then create('rf140','real') endif

tn=tn dn=dn dn2=dn2    "make sure proper frequencies are set"
setfrq
if (numrfch>3) then dn3=dn3 endif
exists('reffrq','parameter'):$e
if ($e=0) then create('reffrq','real') endif
reffrq=sfrq

 if (BPinstall=0) then               "only true at installation"

/* This section creates the HCN probefile with parameters          */
/* (The BPbiopack1b macro makes a copy of the system HCN probefile */
/* instead of making a new probefile)                              */

  write('line3','New "HCN" probe file being created')
  BPaddprobe('HCN')
  write('line3','BioPack parameters added to new probe file')

/* This section sets typical offsets and sw's for magnet used */

    "values of dof,dof2 and tof are ok for 800,750,600 and 500"

  if (h1freq=900) then
    sw=14500 np=2048 dof=dof dof2=dof2 tof=tof
  endif
  if (h1freq=800) then
    sw=13000 np=2048 dof=17400 dof2=2240 tof=-288
  endif
  if (h1freq=750) then
    sw=12000 np=2048 dof=17700 dof2=2230 tof=-288
  endif
  if (h1freq=700) then
    sw=11500 np=2048 dof=dof dof2=dof2 tof=tof
  endif
  "parameters are OK already for 600 MHz"
  if (h1freq=500) then
    sw=8000 np=1024 dof=9620 dof2=1050 tof=-172
  endif
  if (h1freq=400) then
    sw=7000 np=1024 dof=8700 dof2=800 tof=-288
  endif
  if (h1freq=300) then
    sw=5000 np=512 dof=5700 dof2=600 tof=-288
  endif
endif
setref
BPinstall=1      "sets global parameter showing installation is done"          

pw=pw90                         "sets pw if pw was 0 at installation"
printon man('BioPacklist') printoff
man('BioPack.update')
banner('Check printed list for important parameters.\\Then update 
parameter values.\\For VnmrJ:\\click "BioPack Options" tab in Acquire 
Pages.\\     \\Click appropriate "Update" button to finish probefile 
update')
if ($#=0) then menu('BioPack1a') endif

                             Table 6  The BPaddprobe macro    
"BPaddprobe(probename)- macro to add a probe file"
/* This section figures out the active probe directory */
exists(systemdir+'/bin','file','rwx'):$e
if $e then
  $sysadd = 1
  $probedir = systemdir + '/probes'
else
  $sysadd = 0
  $probedir = userdir + '/probes'
endif
exists($probedir,'file'):$e
if not($e) then
  mkdir($probedir)
endif

/* This section backs up existing probefile */
$probe =$1 
$date=''
BPgetdate:$date
$probename=$probedir+'/'+$probe
exists($probename,'file'):$e
if $e then
  mv($probename,$probename+'.bkup_'+$date)
  if $sysadd then
    write('line3','existing system probe file backed up as 
%s',$probe+'.bkup_'+$date)
  else
    write('line3','existing user probe file backed up as 
%s',$probe+'.bkup_'+$date)
  endif
endif
if $sysadd then
  exists(userdir+'/probes/'+$probe,'file'):$e
  if $e then
mv(userdir+'/probes/'+$probe,userdir+'/probes/'+$probe+'.bkup_'+$date)
    write('line3','existing user probe file backed up as 
%s',$probe+'.bkup_'+$date)
  endif
endif
/* This section makes the new probefile */

mkdir($probedir+'/'+$probe)
$probefile = $probedir + '/' + $probe + '/' + $probe
write('reset',$probefile)
write('file',$probefile,'NAME:           %s',$probe)

exists(userdir+'/BioPack.dir/BP_rev','file'):$e
if $e then
 shell('cat '+userdir+'/manual/probe.tmplt >> '+$probefile):$dum
else
 shell('cat '+'/vnmr/manual/probe.tmplt >> '+$probefile):$dum
endif

exists('probe','parameter','global'):$e
if $e<0.5 then
  create('probe','string','global')
  setprotect('probe','on',8,'global')
endif  
probe = $probe
_probe
$file=$probedir + '/' + $probe + '/safety_levels'
write('reset',$file)
write('file',$file,'# Probe protection parameters')
write('file',$file,'# High band power level for 2 Watt')
write('file',$file,'# Low  band power level for 2 Watt')
write('file',$file,'# High band coil energy limit')
write('file',$file,'# Low  band coil energy limit')
exists(systemdir+'acqqueue/acq.conf','file'):$e
if ($e > 0.5) then
  shell('showconsole 1'):$amt
else
  $amt=0
endif
if ($amt=12) then
  write('file',$file,'# For 100W high band/300W low band amplifier')
  write('file',$file,'46.0 42.0 15.0 15.0')
else
  write('file',$file,'# For 50W high band/300W low band amplifier')
  write('file',$file,'49.0 42.0 15.0 15.0')
endif

if $sysadd then
  write('line3','system level probe file %s updated',$probe)
else
  write('line3','user level probe file %s updated',$probe)
endif


banner('Now adding parameters and values to probefile.\\Please wait for 
end message')






/* This section writes out parameter values to probefile */

pw=trunc(10*pw + 0.5)/10
pw90=trunc(10*pw90 + 0.5)/10
pwC=trunc(10*pwC + 0.5)/10
pwN=trunc(10*pwN + 0.5)/10
ref_pw90=trunc(10*pw*compH + 0.5)/10 ref_pwr=tpwr

$gf='' format(gf,4,4):$gf
addparams('gf',$gf,'H1')
$gfs='' format(gfs,4,4):$gfs
addparams('gfs',$gfs,'H1')
$sb='' format(sb,4,4):$sb
addparams('sb',$sb,'H1')
$sbs='' format(sbs,4,4):$sbs
addparams('sbs',$sbs,'H1')
$lb='' format(lb,4,4):$lb
addparams('lb',$lb,'H1')

$ssfilter='' format(ssfilter,4,0):$ssfilter
addparams('ssfilter',$ssfilter,'H1')
$ssntaps='' format(ssntaps,4,0):$ssntaps
addparams('ssntaps',$ssntaps,'H1')
$sslsfrq='' format(sslsfrq,4,4):$sslsfrq
addparams('sslsfrq',$sslsfrq,'H1')
$ssorder='' format(ssorder,2,0):$ssorder
addparams('ssorder',$ssorder,'H1')

$rof1='' format(rof1,4,2):$rof1
addparams('rof1',$rof1,'H1')
$rof2='' format(rof2,4,2):$rof2
addparams('rof2',$rof2,'H1')
$alfa='' format(alfa,4,2):$alfa
addparams('alfa',$alfa,'H1')
$sw='' format(sw,6,1):$sw
addparams('sw',$sw,'H1')
$at='' format(at,5,3):$at
addparams('at',$at,'H1')

$ref_pw90='' format(ref_pw90,2,1):$ref_pw90
addparams('ref_pw90',$ref_pw90,'H1')
$ref_pwr='' format(ref_pwr,2,0):$ref_pwr
addparams('ref_pwr',$ref_pwr,'H1')
$pw90='' format(pw90,2,1):$pw90
addparams('pw90',$pw90,'H1')
addparams('wetpw','6000','H1')
$BPd1='' format(d1,4,4):$BPd1
addparams('BPd1',$BPd1,'H1')
$tpwr='' format(tpwr,2,0):$tpwr
addparams('tpwr',$tpwr,'H1')
addparams('wetpwr','12.0','H1')
addparams('wetshape','gauss','H1')
$tpwrsf='' format(tpwrsf,4,0):$tpwrsf
addparams('tpwrsf',$tpwrsf,'H1')
$phincr_i='' format(0.0,2,2):$phincr_i
addparams('phincr_i',$phincr_i,'H1')
$phincr_t='' format(0.0,2,2):$phincr_t
addparams('phincr_t',$phincr_t,'H1')
$phincr_u='' format(0.0,2,2):$phincr_u
addparams('phincr_u',$phincr_u,'H1')
$phincr_d='' format(0.0,2,2):$phincr_d
addparams('phincr_d',$phincr_d,'H1')
$phincr_n='' format(0.0,2,2):$phincr_n
addparams('phincr_n',$phincr_n,'H1')
$tpwrsf_i='' format(tpwrsf,4,0):$tpwrsf_i
addparams('tpwrsf_i',$tpwrsf_i,'H1')
$tpwrsf_t='' format(tpwrsf,4,0):$tpwrsf_t
addparams('tpwrsf_t',$tpwrsf_t,'H1')
$tpwrsf_u='' format(tpwrsf,4,0):$tpwrsf_u
addparams('tpwrsf_u',$tpwrsf_u,'H1')
$tpwrsf_d='' format(tpwrsf,4,0):$tpwrsf_d
addparams('tpwrsf_d',$tpwrsf_d,'H1')
$tpwrsf_n='' format(tpwrsf,4,0):$tpwrsf_n
addparams('tpwrsf_n',$tpwrsf_n,'H1')
addparams('finepwrf',$tpwrsf,'H1')
$pwHs='' format(pwHs,2,1):$pwHs
addparams('pwHs',$pwHs,'H1')
addparams('pwHs2',$pwHs,'H1')
$waltzB1='' format(waltzB1,6,0):$waltzB1
addparams('waltzB1',$waltzB1,'H1')
$tofH2O='' format(tof,4,1):$tofH2O
addparams('tofH2O',$tofH2O,'H1')
$compH='' format(compH,4,3):$compH
addparams('compH',$compH,'H1')
$BPgain='' format(gain,2,0):$BPgain
addparams('BPgain',$BPgain,'H1')
$rna_gain='' format(gain,2,0):$rna_gain
addparams('rna_gain',$rna_gain,'H1')
$BPtemp='' format(temp,3,1):$BPtemp
addparams('BPtemp',$BPtemp,'H1')

$pwC='' format(pwC,2,1):$pwC
addparams('pwC',$pwC,'C13')
$pwC3db='' format(1.4*pwC,2,1):$pwC3db
addparams('pwC3db',$pwC3db,'C13')
$pwClvl='' format(pwClvl,2,0):$pwClvl
addparams('pwClvl',$pwClvl,'C13')
$compC='' format(compC,4,3):$compC
addparams('compC',$compC,'C13')
$compC3db='' format(compC,4,3):$compC3db
addparams('compC3db',$compC3db,'C13')
$dofCO='' format(dof,4,1):$dofCO
addparams('dofCO',$dofCO,'C13')
$swCO='' format(sw1,4,1):$swCO
addparams('swCO',$swCO,'C13')
addparams('phi7cal','0.0','C13')
addparams('phi7calP','60.0','C13')
addparams('phi_CO','0.0','C13')
addparams('phi_Ca','0.0','C13')
addparams('phshift3','O.0','C13')




"next three will be set by autocalibrate of gChsqc"
$CHgrad1_time='' format(gt1,8,6):$CHgrad1_time
addparams('CHgrad1_time',$CHgrad1_time,'C13')
$CHgrad1_lvl='' format(gzlvl1,6,0):$CHgrad1_lvl
addparams('CHgrad1_lvl',$CHgrad1_lvl,'C13')
$CHgrad2_lvl='' format(gzlvl2,6,0):$CHgrad2_lvl
addparams('CHgrad2_lvl',$CHgrad2_lvl,'C13')
$CHgstab='' format(gstab,6,6):$CHgstab
addparams('CHgstab',$CHgstab,'C13')

"next three will be used by ghcch_tocsy"
$hcch_gtime='' format(0.0008,8,6):$hcch_gtime
addparams('hcch_gtime',$hcch_gtime,'C13')
$hcch_gzlvl1='' format(gzlvl1,6,0):$hcch_gzlvl1
addparams('hcch_gzlvl1',$hcch_gzlvl1,'C13')
$hcch_gzlvl2='' format(gzlvl2,6,0):$hcch_gzlvl2
addparams('hcch_gzlvl2',$hcch_gzlvl2,'C13')

$spinlock='' format(BPspinlock,4,1):$spinlock
addparams('spinlock',$spinlock,'C13')
$dmf30='' format(dmf30,4,1):$dmf30
addparams('dmf30',$dmf30,'C13')
$dmf80='' format(dmf80,4,1):$dmf80
addparams('dmf80',$dmf80,'C13')
$dmf140='' format(dmf140,4,1):$dmf140
addparams('dmf140',$dmf140,'C13')
$rf30='' format(rf30,4,1):$rf30
addparams('rf30',$rf30,'C13')
$rf80='' format(rf80,4,1):$rf80
addparams('rf80',$rf80,'C13')
$rf140='' format(rf140,4,1):$rf140
addparams('rf140',$rf140,'C13')

$pwN='' format(pwN,2,1):$pwN
addparams('pwN',$pwN,'N15')
$pwNlvl='' format(pwNlvl,2,0):$pwNlvl
addparams('pwNlvl',$pwNlvl,'N15')
$compN='' format(compN,4,3):$compN
addparams('compN',$compN,'N15')
$dofN15='' format(dof2,4,1):$dofN15
addparams('dofN15',$dofN15,'N15')
$swN='' format(sw2,4,1):$swN
addparams('swN',$swN,'N15')
$dpwr2NH='' format(dpwr2,2,0):$dpwr2NH
addparams('dpwr2NH',$dpwr2NH,'N15')
addparams('dmm2NH',dmm2,'N15')
$dres2NH='' format(dres2,5,1):$dres2NH
addparams('dres2NH',$dres2NH,'N15')
$dmf2NH='' format(dmf2,3,1):$dmf2NH
addparams('dmf2NH',$dmf2NH,'N15')
$JNH='' format(JNH,3,1):$JNH
addparams('JNH',$JNH,'N15')





$gt0='' format(gt0,1,6):$gt0
addparams('gt0',$gt0,'N15')
$gt5='' format(gt5,1,6):$gt5
addparams('gt5',$gt5,'N15')
$gzlvl5='' format(gzlvl5,6,0):$gzlvl5
addparams('gzlvl5',$gzlvl5,'N15')
$gzlvl0='' format(gzlvl0,6,0):$gzlvl0
addparams('gzlvl0',$gzlvl0,'N15')
$gzlvl5='' format(gzlvl5,6,0):$gzlvl5
addparams('gzlvl5',$gzlvl5,'N15')
$NHgrad1_time='' format(gt1,8,6):$NHgrad1_time
addparams('NHgrad1_time',$NHgrad1_time,'N15')
$NHgrad1_lvl='' format(gzlvl1,4,0):$NHgrad1_lvl
addparams('NHgrad1_lvl',$NHgrad1_lvl,'N15')
$NHgrad2_lvl='' format(gzlvl2,4,0):$NHgrad2_lvl
addparams('NHgrad2_lvl',$NHgrad2_lvl,'N15')
$BPgzcal='' format(gzcal,6,6):$BPgzcal
addparams('BPgzcal',$BPgzcal,'N15')
$NHgstab='' format(gstab,6,6):$NHgstab
addparams('NHgstab',$NHgstab,'N15')
addparams('mag_flg',mag_flg,'N15')

$dres3D='' format(dres3,2,1):$dres3D
addparams('dres3D',$dres3D,'H2')
$dpwr3D='' format(dpwr3,2,0):$dpwr3D
addparams('dpwr3D',$dpwr3D,'H2')
$dmf3D='' format(dmf3,5,1):$dmf3D
addparams('dmf3D',$dmf3D,'H2')
$dof3D='' format(dof3,5,1):$dof3D
addparams('dof3D',$dof3D,'H2')
addparams('dseq3D',dseq3,'H2')
addparams('dmm3D',dmm3,'H2')

banner('probefile setup finished.')

          Table 7.  The BPbiopack2 macro    

"BPbiopack2 updates parameters values in probefile"
"using parameter values in current parameter table"

$probename=probe
if ($probename='') then
  banner('No Probe is specified. New Probefile "HCN" is being created')
  BPaddprobe('HCN')
endif
banner('Probe File Is Being Updated with These Calibrations')

/* This section creates parameters if missing */

"add new parameters if missing"
exists('autocal','parameter'):$e
 if $e=0 then create('autocal','string') autocal='y' endif
exists('checkofs','parameter'):$e
 if $e=0 then create('checkofs','string') checkofs='n' endif
exists('JNH','parameter'):$e
 if $e=0 then create('JNH','real') JNH=93 endif
exists('waltzB1','parameter'):$e
 if $e=0 then create('waltzB1','real') waltzB1=5p endif
exists('dmf30','parameter'):$e
 if $e=0 then create('dmf30','real') dmf30=0 endif
exists('dmf80','parameter'):$e
 if $e=0 then create('dmf80','real') dmf80=0 endif
exists('dmf140','parameter'):$e
 if $e=0 then create('dmf140','real') dmf140=0 endif
exists('rf30','parameter'):$e
 if $e=0 then create('rf30','real') rf30=0 endif
exists('rf80','parameter'):$e
 if $e=0 then create('rf80','real') rf80=0 endif
exists('rf140','parameter'):$e
 if $e=0 then create('rf140','real') rf140=0 endif

/* This section makes sure pulse widths are multiple of 0.1usec */

pw=trunc(10*pw + 0.5)/10
pw90=trunc(10*pw + 0.5)/10
pwC=trunc(10*pwC + 0.5)/10
pwN=trunc(10*pwN + 0.5)/10
ref_pw90=trunc(10*pw*compH + 0.5)/10 ref_pwr=tpwr

/* Saves ghn_co parameter set in user (or vnmr) parlib */

if seqfil='ghn_co' then
 BPsvp('ghn_co')   "saves in either /vnmr/parlib or user account"
endif


/* This section updates processing parameters. BPsetparams is a
   version of setparams that creates and sets a parameter if it 
   is not present in the probefile  */

$lb='' format(lb,4,4):$lb
BPBPsetparams('lb',$lb,'H1')
$gf='' format(gf,4,4):$gf
BPsetparams('gf',$gf,'H1')
$gfs='' format(gfs,4,4):$gfs
BPsetparams('gfs',$gfs,'H1')
$sb='' format(sb,4,4):$sb
BPsetparams('sb',$sb,'H1')
$sbs='' format(sbs,4,4):$sbs
BPsetparams('sbs',$sbs,'H1')


$ssfilter='' format(ssfilter,4,0):$ssfilter
BPsetparams('ssfilter',$ssfilter,'H1')
$ssntaps='' format(ssntaps,4,0):$ssntaps
BPsetparams('ssntaps',$ssntaps,'H1')
$sslsfrq='' format(sslsfrq,4,4):$sslsfrq
BPsetparams('sslsfrq',$sslsfrq,'H1')
$ssorder='' format(ssorder,2,0):$ssorder
BPsetparams('ssorder',$ssorder,'H1')





/* This section updates acquisition parameters */

$rof1='' format(rof1,4,2):$rof1
BPsetparams('rof1',$rof1,'H1')
$rof2='' format(rof2,4,2):$rof2
BPsetparams('rof2',$rof2,'H1')
$alfa='' format(alfa,4,2):$alfa
BPsetparams('alfa',$alfa,'H1')
$sw='' format(sw,6,1):$sw
BPsetparams('sw',$sw,'H1')
$at='' format(at,5,3):$at
BPsetparams('at',$at,'H1')
$BPd1='' format(d1,2,3):$BPd1
BPsetparams('BPd1',$BPd1,'H1')
$BPgain='' format(gain,2,0):$BPgain
BPsetparams('BPgain',$BPgain,'H1')
$BPtemp='' format(temp,3,1):$BPtemp
BPsetparams('BPtemp',$BPtemp,'H1')

/* This section updates 1H RF parameters */

$ref_pw90='' format(ref_pw90,2,1):$ref_pw90
BPsetparams('ref_pw90',$ref_pw90,'H1')
$ref_pwr='' format(ref_pwr,2,0):$ref_pwr
BPsetparams('ref_pwr',$ref_pwr,'H1')
$pw90='' format(pw90,2,1):$pw90
BPsetparams('pp',$pw90,'H1')
BPsetparams('pw90',$pw90,'H1')
$waltzB1='' format(waltzB1,6,0):$waltzB1
BPsetparams('waltzB1',$waltzB1,'H1')
$tpwr='' format(tpwr,2,0):$tpwr
BPsetparams('tpwr',$tpwr,'H1')
BPsetparams('pplvl',$tpwr,'H1')
$dmf=1e6/(pw*10*compH) $dpwr=tpwr-20
$dmfH1='' format($dmf,5,0):$dmfH1
$dpwrH1='' format($dpwr,2,0):$dpwrH1
BPsetparams('dmf',$dmfH1,'H1')
BPsetparams('dpwr',$dpwrH1,'H1')
$tofH2O='' format(tof,4,1):$tofH2O
BPsetparams('tofH2O',$tofH2O,'H1')
$compH='' format(compH,4,3):$compH
BPsetparams('compH',$compH,'H1')
BPsetparams('tpwr_cf',$compH,'H1')

/* This section updates 13C RF parameters */

$pwC='' format(pwC,2,1):$pwC
BPsetparams('pwC',$pwC,'C13')
BPsetparams('pw90',$pwC,'C13')
BPsetparams('pwx',$pwC,'C13')
$pwClvl='' format(pwClvl,2,0):$pwClvl
BPsetparams('pwClvl',$pwClvl,'C13')
BPsetparams('tpwr',$pwClvl,'C13')
BPsetparams('pwxlvl',$pwClvl,'C13')
$compC='' format(compC,4,3):$compC
BPsetparams('compC',$compC,'C13')
BPsetparams('pwxlvl_cf',$compC,'C13')
/* This section updates 15N RF parameters */

$pwN='' format(pwN,2,1):$pwN
BPsetparams('pwN',$pwN,'N15')
BPsetparams('pw90',$pwN,'N15')
BPsetparams('pwx',$pwN,'N15')
$pwNlvl='' format(pwNlvl,2,0):$pwNlvl
BPsetparams('pwNlvl',$pwNlvl,'N15')
BPsetparams('tpwr',$pwNlvl,'N15')
BPsetparams('pwxlvl',$pwNlvl,'N15')
$compN='' format(compN,4,3):$compN
BPsetparams('compN',$compN,'N15')
BPsetparams('pwxlvl_cf',$compN,'N15')
$dpwr2NH='' format(dpwr2,2,0):$dpwr2NH
BPsetparams('dpwr2NH',$dpwr2NH,'N15')
BPsetparams('dmm2NH',dmm2,'N15')
BPsetparams('dmm',dmm2,'N15')
BPsetparams('dpwr',$dpwr2NH,'N15')
BPsetparams('dmm',dmm2,'N15')
$dres2NH='' format(dres2,5,1):$dres2NH
BPsetparams('dres2NH',$dres2NH,'N15')
BPsetparams('dres',$dres2NH,'N15')
$dmf2NH='' format(dmf2,3,1):$dmf2NH
BPsetparams('dmf2NH',$dmf2NH,'N15')
BPsetparams('dmf',$dmf2NH,'N15')

/* This section updates gradient parameters */
$BPgzcal='' format(gzcal,8,6):$BPgzcal
BPsetparams('gcal',$BPgzcal,'Probe')
BPsetparams('gradient','y','Probe')
BPsetparams('BPgzcal',$BPgzcal,'N15')
BPsetparams('mag_flg',mag_flg,'N15')

/* This section updates parameters used by ghn_co */

if (seqfil='ghn_co') then
  $pwHs='' format(pwHs,2,1):$pwHs
  BPsetparams('pwHs',$pwHs,'H1')
  $tpwrsf='' format(tpwrsf,4,0):$tpwrsf
  BPsetparams('tpwrsf',$tpwrsf,'H1')
  $dofCO='' format(dof,4,1):$dofCO
  BPsetparams('dofCO',$dofCO,'C13')
  $swCO='' format(sw1,4,1):$swCO
  BPsetparams('swCO',$swCO,'C13')
  $spinlock='' format(BPspinlock,4,1):$spinlock
  BPsetparams('spinlock',$spinlock,'C13')
  $dofN15='' format(dof2,4,1):$dofN15
  BPsetparams('dofN15',$dofN15,'N15')
  $swN='' format(sw2,4,1):$swN
  BPsetparams('swN',$swN,'N15')
  $JNH='' format(JNH,3,1):$JNH
  BPsetparams('JNH',$JNH,'N15')
  $NHgrad1_time='' format(gt1,8,6):$NHgrad1_time
  BPsetparams('NHgrad1_time',$NHgrad1_time,'N15')
  $NHgrad1_lvl='' format(gzlvl1,6,0):$NHgrad1_lvl
  BPsetparams('NHgrad1_lvl',$NHgrad1_lvl,'N15')
  $NHgrad2_lvl='' format(gzlvl2,6,0):$NHgrad2_lvl
  BPsetparams('NHgrad2_lvl',$NHgrad2_lvl,'N15')
  $NHgstab='' format(gstab,6,4):$NHgstab
  BPsetparams('NHgstab',$NHgstab,'N15')
  $gt5='' format(gt5,1,6):$gt5
  BPsetparams('gt5',$gt5,'N15')
  $gt0='' format(gt0,1,6):$gt0
  BPsetparams('gt0',$gt0,'N15')
  $gzlvl5='' format(gzlvl5,6,0):$gzlvl5
  BPsetparams('gzlvl5',$gzlvl5,'N15')
  $gzlvl0='' format(gzlvl0,6,0):$gzlvl0
  BPsetparams('gzlvl0',$gzlvl0,'N15')
  $dres3D='' format(dres3,2,1):$dres3D
  BPsetparams('dres3D',$dres3D,'H2')
  $dpwr3D='' format(dpwr3,2,0):$dpwr3D
  BPsetparams('dpwr3D',$dpwr3D,'H2')
  $dmf3D='' format(dmf3,5,1):$dmf3D
  BPsetparams('dmf3D',$dmf3D,'H2')
  $dof3D='' format(dof3,5,1):$dof3D
  BPsetparams('dof3D',$dof3D,'H2')
  if dseq3='' then dseq3='garp1' endif
  BPsetparams('dseq3D',dseq3,'H2')
  BPsetparams('dmm3D',dmm3,'H2')

/* This section makes RF shapes and Decoupling shapes using 
calibrations present in this parameter set (See Tables 8 and 9) */
  BPsetupshapes                   "makes Pbox waveforms"  
  BPcal                           "makes rf waveforms"
/* This section makes STUD shapes and stores calibrations for STUD */
  BPmakeSTUDpp "makes STUD waveforms and sets dmf30, rf30, etc"
  $dmf30='' format(dmf30,4,1):$dmf30
  BPsetparams('dmf30',$dmf30,'C13')
  $dmf80='' format(dmf80,4,1):$dmf80
  BPsetparams('dmf80',$dmf80,'C13')
  $dmf140='' format(dmf140,4,1):$dmf140
  BPsetparams('dmf140',$dmf140,'C13')
  $rf30='' format(rf30,4,1):$rf30
  BPsetparams('rf30',$rf30,'C13')
  $rf80='' format(rf80,4,1):$rf80
  BPsetparams('rf80',$rf80,'C13')
  $rf140='' format(rf140,4,1):$rf140
  BPsetparams('rf140',$rf140,'C13')
endif

/* BPbiopack2 can be called from autocalibration involving the RNA 
sequences "rna_gNhsqc" or "rna_gChsqc", so current parameters are not 
for ghn_co */
if (seqfil='rna_gNhsqc') then
  $NHgrad1_time='' format(gt1,8,6):$NHgrad1_time
  BPsetparams('NHgrad1_time',$NHgrad1_time,'N15')
  $NHgrad1_lvl='' format(gzlvl1,6,0):$NHgrad1_lvl
  BPsetparams('NHgrad1_lvl',$NHgrad1_lvl,'N15')
  $NHgrad2_lvl='' format(gzlvl2,6,0):$NHgrad2_lvl
  BPsetparams('NHgrad2_lvl',$NHgrad2_lvl,'N15')
  $NHgstab='' format(grecov,6,4):$NHgstab
  BPsetparams('NHgstab',$NHgstab,'N15')
endif
if (seqfil='rna_gChsqc') then
  $CHgrad1_time='' format(gt1,8,6):$CHgrad1_time
  BPsetparams('CHgrad1_time',$CHgrad1_time,'C13')
  $CHgrad1_lvl='' format(gzlvl1,6,0):$CHgrad1_lvl
  BPsetparams('CHgrad1_lvl',$CHgrad1_lvl,'C13')
  $CHgrad2_lvl='' format(gzlvl2,6,0):$CHgrad2_lvl
  BPsetparams('CHgrad2_lvl',$CHgrad2_lvl,'C13')
  $CHgstab='' format(grecov,6,4):$CHgstab
  BPsetparams('CHgstab',$CHgstab,'C13')
  BPcal        "makes rf waveforms"
  BPmakeSTUDpp "makes STUD waveforms and sets dmf30, rf30, etc"
  $dmf30='' format(dmf30,4,1):$dmf30
  BPsetparams('dmf30',$dmf30,'C13')
  $dmf80='' format(dmf80,4,1):$dmf80
  BPsetparams('dmf80',$dmf80,'C13')
  $dmf140='' format(dmf140,4,1):$dmf140
  BPsetparams('dmf140',$dmf140,'C13')
  $rf30='' format(rf30,4,1):$rf30
  BPsetparams('rf30',$rf30,'C13')
  $rf80='' format(rf80,4,1):$rf80
  BPsetparams('rf80',$rf80,'C13')
  $rf140='' format(rf140,4,1):$rf140
  BPsetparams('rf140',$rf140,'C13')
endif
write('line3','Probefile Update Finished')
banner('Probe File Updated with These Calibrations')
                      
6.0	Making Shapelib Files: RF and Decoupling Waveforms

Several macros are used within the probefile update process. BPsetupshapes and BPcal 
are macros that create waveforms for decoupling and band-selective excitation. They are
executed during the probefile update because this is when (possibly) new calibrations 
have been determined. Since decoupling waveforms depend on reference pw90's, power 
levels and compression factors, having the waveforms recreated during BPbiopack2 
execution guarantees that the waveforms and their internal parameters are consistent with 
probe calibrations. Once the waveforms have been created, the BPsetwurstparams macro 
can be used in experiment setup macros (e.g. "gChsqc") to install calibrated parameter 
values for decoupling and spinlocks.

            Table 8. The BPsetupshapes macro   

/* BPsetupshapes.     For alphas,aliphatics, aromatics or allC, this 
creates waveforms WURSTxx.DEC, where xx is the number of 13C ppm 
bandwidth. if BPpwrlimits=1, power levels may reduced, but bandwidths 
remain, at the expense of increased sidebands*/

$bw = ''
$wave = ''
$name = ''
$n3=n3
format(BPmaxdpwr,2,0):n3
n3=n3+'d'
$attn=n3

/* The section checks for value of global variable BPspinlock and
   makes the 13C Spinlock waveform cctocsy.DEC. It then stores it in 
   either the system shapelib( if vnmr1) or the user shapelib. */ 

exists('BPspinlock','parameter','global'):$e2
if $e2=1 then
   if BPspinlock=0 then "set C13 spinlock bandwidth to default value"
    BPspinlock=50d        
   endif
else 
   create('BPspinlock','real','global')
   BPspinlock=50d     "set C-13 spinlock bandwidth to default value"
endif
format(BPspinlock,9,1):$bw  


 $wave = 'WURST2m' + $bw + '/0.08ms'
 opx			          " setup CC spinlock "
 setwave($wave)  
 pbox_rst
 pboxpar('name', 'cctocsy.DEC')
 pboxpar('stepsize', '1.0')
 pboxpar('sfrq', dfrq)
 pboxpar('sucyc', 't9,t5,m4')
 pboxpar('ref_pwr', pwClvl)
 pboxpar('ref_pw90', pwC*compC)
 " pboxpar('reps', '0')  - to suppress the Pbox output "
 shell('Pbox')
 if BPpwrlimits=1 then
  BPpboxget('cctocsy.DEC'):$name,$par,$dpwr,$par,$par,$par
  if $dpwr>BPdpwrmax then             "recreate shape at lower power"
     pboxpar('attn',$attn)
     echo($attn)
     shell('Pbox')
  endif
 endif
 BPmoveshape('cctocsy.DEC')            "puts shape in proper shapelib"

/* The section prepares broadband 13C decoupling waveforms in the form 
   of wurstxx.DEC where xx is the bandwidth in ppm. It then stores each
   in either the system shapelib (if vnmr1) or the user shapelib. */ 

format(90.0*sfrq/4.0,9,1):$bw  "set C13 bandwidth to 80 ppm "
if BPpwrlimits=1 then
 $wave = 'WURST40' + $bw + '/1.4ms'
else
 $wave = 'WURST2' + $bw + '/1.01ms'
endif
opx
setwave($wave)
pbox_rst
if BPpwrlimits=0 then
 pboxpar('$1 adb','3.0') " can omit for less power, but > sideband"
endif
pboxpar('name', 'wurst80.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
" pboxpar('reps', '0')  - to suppress the Pbox output "
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst80.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('wurst80.DEC')

format(130.0*sfrq/4.0,9,1):$bw      " set C13 bandwidth to 110 ppm "
if BPpwrlimits=1 then
 $wave = 'WURST40' + $bw + '/1.4ms'
else
 $wave = 'WURST2' + $bw + '/1.01ms'
endif
opx
setwave($wave)
pbox_rst
pboxpar('name', 'wurst110.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
" pboxpar('reps', '0')  - to suppress the Pbox output "
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst110.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('wurst110.DEC')

format(60.0*sfrq/4.0,9,1):$bw "set C-13 decoupling bandwidth to 50 ppm"
if BPpwrlimits=1 then
 $wave = 'WURST40' + $bw + '/1.4ms'
else
 $wave = 'WURST2' + $bw + '/1.01ms'
endif
opx
setwave($wave)
pbox_rst
if BPpwrlimits=0 then
 pboxpar('$1 adb','3.0') " can omit for 3db less power, but > sideband"
endif
pboxpar('name', 'wurst50.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
" pboxpar('reps', '0')  - to suppress the Pbox output "
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst50.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('wurst50.DEC')

format(45.0*sfrq/4.0,9,1):$bw    " set C13 bandwidth to 40 ppm "
if BPpwrlimits=1 then
 $wave = 'WURST40' + $bw + '/1.4ms'
else
 $wave = 'WURST2' + $bw + '/1.01ms'
endif
opx
setwave($wave)
pbox_rst
if BPpwrlimits=0 then
 pboxpar('$1 adb','3.0') " can omit for 3db less power, but > sideband"
endif
pboxpar('name', 'wurst40.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
" pboxpar('reps', '0')  - to suppress the Pbox output "
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst40.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('wurst40.DEC')

format(160.0*sfrq/4.0,9,1):$bw    " set C13 bandwidth to 140 ppm "
if BPpwrlimits=1 then
 $wave = 'WURST40' + $bw + '/1.4ms'
else
 $wave = 'WURST2' + $bw + '/1.01ms'
endif
opx
setwave($wave)
pbox_rst
if BPpwrlimits=0 then
 pboxpar('$1 adb','3.0') "can omit for 3db less power, but > sideband"
endif
pboxpar('name', 'wurst140.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst140.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('wurst140.DEC')

/* The section prepares band-selective 13C decoupling waveforms. It 
then stores each in either the appropriate shapelib */
opx			          " set COCb decoupling "
setwave('WURST2 20p/5m 175p')  " CO decoupling "
setwave('WURST2 22p/5m 36p')   " main Cb band "
setwave('WURST2  6p/5m 71p')   " Threonines "
setwave('WURST2  6p/5m 15p')   " Alanines "
pbox_rst
pboxpar('name', 'cocbdec.DEC')
pboxpar('stepsize', '4.0')
pboxpar('sfrq', dfrq)
pboxpar('refofs', '56p')
pboxpar('sucyc', 't5')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
" pboxpar('reps', '0')  - to suppress the Pbox output "
pboxpar('$1 adb', '2.0') "more power for CO dec as it is further away"
pboxpar('$2 adb', '1.2')
pboxpar('$3 adb', '1.2')
pboxpar('$4 adb', '1.2')
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('cocbdec.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('cocbdec.DEC')

opx			          " set COCa decoupling "
setwave('WURST2 20p/5m 174p')  " CO decoupling "
setwave('WURST2 22p/5m 30p')   " Ca decoupling "
pbox_rst
pboxpar('name', 'cocadec.DEC')
pboxpar('stepsize', '4.0')
pboxpar('sfrq', dfrq)
pboxpar('refofs', '56p')
pboxpar('sucyc', 't5')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
pboxpar('$1 adb', '2.0') "more power for CO dec as it is further away"
pboxpar('$2 adb', '1.2')
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('cocadec.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('cocadec.DEC')

opx			          " set CO decoupling "
setwave('WURST2 20p/5m 174p')  " CO decoupling "
pbox_rst
pboxpar('name', 'codec.DEC')
pboxpar('stepsize', '4.0')
pboxpar('sfrq', dfrq)
pboxpar('refofs', '35p')
pboxpar('sucyc', 't5')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
pboxpar('$1 adb', '2.0') "more power for CO dec as it is further away"
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('codec.DEC'):$name,$par,$dpwr,$par,$par,$par
 if $dpwr>BPdpwrmax then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
BPmoveshape('codec.DEC')

$bw1 = ''
$wave1 = ''
$offset = ''
$dmmyshp=''
$freq = -(150-46)*dfrq  " distance from Cab to the CO/ aromatic region"
format(80.0*dfrq,9,1):$bw1   " set decoupling bandwidth to 90 ppm "
format($freq,9,1):$offset
$wave1 = 'g3' + $bw1 + '/0.005' + $offset +'0 0' "ph=0 st=0"
opx
setwave($wave1)
pbox_rst
pboxpar('name', 'CgCO1.RF')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
shell('Pbox')

$bw1 = ''
$wave1 = ''
$offset = ''
$freq = -(150-46)*dfrq  " distance from Cab to the CO/ aromatic region"
format(80.0*dfrq,9,1):$bw1   " set decoupling bandwidth to 90 ppm "
format($freq,9,1):$offset
$wave1 = 'g3' + $bw1 + '/0.005' + $offset +'0 1' "ph=0 st=1 time-
inversed"

opx
setwave($wave1)
pbox_rst
pboxpar('name', 'CgCO2.RF')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
shell('Pbox')
BPmoveshape('CgCO1.RF')
BPmoveshape('CgCO2.RF')

"make CaCO.DEC"
$bw1 = ''
$bw2 = ''
$wave1 = ''
$wave2 = ''
$offset = ''
$freq = -(174-56)*dfrq           " distance to alpha carbon region"
format(40.0*dfrq,9,1):$bw1   " set Ca decoupling bandwidth to 40 ppm "
format(20.0*dfrq,9,1):$bw2   " set CO decoupling bandwidth to 20 ppm "
format($freq,9,1):$offset   
$wave1 = 'WURST2' + $bw1 + '/1.01ms' + $offset
$wave2 = 'WURST2' + $bw2 + '/1.01ms'
opx
setwave($wave1)
setwave($wave2)
pbox_rst
pboxpar('name', 'CaCO.DEC')
pboxpar('ref_pwr', pwClvl)
pboxpar('ref_pw90', pwC*compC)
shell('Pbox')
BPmoveshape('CaCO.DEC')

/* The section prepares solvent suppression 1H waveforms. It then 
stores each in either the appropriate */ 
if (sfrq>810) then
   opx('S_at_12p')
   setwave('s 0.000064')
   cpx(pw*compH,tpwr)
 endif
 if ((sfrq>760) and (sfrq<810)) then
   opx('S_at_12p')
   setwave('s 0.000072')
   cpx(pw*compH,tpwr)
 endif
 if ((sfrq>590) and (sfrq<610)) then
   opx('S_at_12p')
   setwave('s 0.000096')
   cpx(pw*compH,tpwr)
 endif
 if ((sfrq>490) and (sfrq<510)) then
   opx('S_at_12p')
   setwave('s 0.000115')
   cpx(pw*compH,tpwr)
 endif
 if ((sfrq>390) and (sfrq<410)) then
   opx('S_at_12p')
   setwave('s 0.000144')
   cpx(pw*compH,tpwr)
 endif
 if ((sfrq>290) and (sfrq<310)) then
   opx('S_at_12p')
   setwave('s 0.000192')
   cpx(pw*compH,tpwr)
 endif
BPmoveshape('S_at_12p.RF')
n3=$n3                        "n3 was memorized above. Now is restored"

         Table 9.  The BPcal macro  

/* This macro runs other macros, each of which produces an RF shaped 
   pulse file that is stored in the appropriate shapelib. The basis of
   this is that sfrq is known to the macro so that phase-ramped shaped
   pulses may be created with proper pulse widths and phase ramps to 
   achieve the desired excitation. Pulse widths can be calculated in 
   each macro for the desired effect. The same equations are used in 
   the experiment setup macros. Shapes are first created for the 
   maximum number of steps possible (200nsec per step) and these are
   usually rectangular or sinc-shaped. If off-resonance excitation is
   desired, a phase ramp is imposed on the shape using the BPconvolute
   macro. The end results are shapes that are used with specific pulse
   widths, but the amplitudes are not determined. These are determined
   by the pulse sequence code itself (except for those sequences 
   directly using Pbox to produce the shaped pulses). See Table 10 */

exists(userdir+'/shapelib','directory'):$exists
if $exists<1 then mkdir(userdir+'/shapelib') endif

/* 180 degree inversion pulse across 200ppm, centered on dof, to invert  
all C13 nuclei when dof=70ppm */
BPmakestC200

/* 180 degree inversion pulse across 140ppm, centered on dof, to invert  
all C13 nuclei when dof=70ppm */
BPmakestC140

/* 180 degree inversion pulse across 80ppm, centered on dof, to invert  
all aliphatic C13 nuclei without perturbing protein aromatic or CO 
C13 nuclei when dof=35ppm*/
BPmakestC80

/* 180 degree inversion pulse across 30ppm, centered on dof, to invert  
all aromatic C13 nuclei without perturbing protein aliphatic C13
nuclei when dof=125ppm, OR to invert Ca's without perturbing protein
aromatic or CO  C13 nuclei when dof=56ppm*/
BPmakestC30

/* 3 ms 180 degree pulse across 50ppm, with the 10% left-hand edge of    
the inversion at 50 ppm when dof=56ppm, to invert Cb's to the right of 
the Ca's */
BPmakestC50_3r

/* 5 ms 180 degree pulse across 50ppm, with the 3% left-hand edge of 
the inversion at 50 ppm when dof=56ppm, to invert Cb's to the right of 
the Ca's */
BPmakestC50_5r

/* 3 ms 180 degree pulse across 50ppm, with the 10% right-hand edge of 
the inversion at 63 ppm when dof=56ppm, to invert Cb's to the left of 
the Ca's. A narrower inversion can be used, but it is handy for all 
other aspects to be the same as stC50r"
BPmakestC50_3l


/* 5 ms 180 degree pulse across 50ppm, with the 3% right-hand edge of 
the inversion at 63 ppm when dof=56ppm, to invert Cb's to the left of 
the Ca's. A narrower inversion can be used, but it is handy for all 
other aspects to be the same as stC50r*/
BPmakestC50_5l

/* 10 ms 180 degree pulse across 12.5ppm, from 50ppm to 62.5ppm for to 
dof at 35ppm, to invert Ca's and not touch almost all Cb's  */
BPmakestC12_10

/* 180 degree inversion pulse across 30ppm, centered on dof, to invert  
"all RNA aromatic C2/C6/C8 (dof=150ppm) C13 nuclei without perturbing 
RNA pyrimidine C5 and ribose C13 nuclei */
rna_makestC30

/* 180 degree inversion pulse across 50ppm, centered on dof, to invert  
all RNA ribose and pyrimidine C5 (dof=85ppm) C13 nuclei without 
perturbing RNA aromatic C2/C6/C8 C13 nuclei */
rna_makestC50

/* 180 degree inversion pulse across 80ppm, centered on dof, to invert  
all RNA aromatic C5/C6/C8 (dof=125ppm) C13 nuclei without perturbing 
RNA ribose nuclei */
rna_makestC80

/* 180 degree inversion pulse across 60ppm, centered on dof, to invert  
all RNA ribose C1' and aromatic C6/C8 (dof=115ppm) C13 nuclei without 
perturbing RNA ribose C2' and aromatic C2 C13 nuclei */
rna_makestC60

/* 180 degree inversion pulse across 140ppm, centered on dof, to invert  
all C13 nuclei when dof=110ppm */
rna_makestC140

/* 180 degree inversion pulse across 50ppm, centered on dof2, to invert  
all aromatic N1/N9 N15 nuclei when dof2=155ppm */
rna_makestN50

/* 180 degree inversion pulse across 100ppm, centered on dof2 
*/rna_makestN100

/*90 degree selective one-lobe pulse on H2O (1.2 ppm), < 1% excitation 
off resonance*/
rna_makeH2Osinc

/*90 degree selective one-lobe pulse on H2O (0.5 ppm), < 1% excitation 
off resonance*/
rna_makeH2Osinc1     

/*flopsy8 decoupling pattern will be made only if not already present*/
rna_makeflopsy8

/*dipsi2 decoupling pattern will be made only if not already present*/
rna_makedipsi2
/*90 degree square pulse on Ca, null at CO, 118ppm away. C13 frequency 
at CO. Generates offC13.RF*/
BPmake90Ca_CO
/*180 degree square pulse on Ca, null at CO, 118ppm away. C13 frequency 
at CO. Generates offC3.RF*/
BPmake180Ca_CO

/*180 degree square pulse on Ca, null at CO, 118ppm away. C13 frequency 
at Cab. Generates offC4.RF*/
BPmake180Ca

/*90 degree selective sinc one-lobe pulse on CO, first null at Ca.  C13 
frequency at Ca. Generates offC2.RF*/ 
BPmake90CO_Ca

/*90 degree selective sinc one-lobe pulse on CO, first null at Ca.  C13  
frequency at Cab. Generates offC5.RF*/
BPmake90CO

/*90 degree selective sinc one-lobe pulse on CO, first null at Ca.  C13 
frequency at CO. Generates offC6.RF*/
BPmake90CO_CO

/*180 degree selective sinc one-lobe pulse on Cab.  C13 frequency at 
CO.  Generates offC27.RF*/
BPmake180Cab_CO

/*180 degree selective sinc one-lobe pulse on CO, first null at Ca.*/ 
      /*C13 frequency at Cab.  Generates offC7.RF*/
         BPmake180CO
      /*C13 frequency at CO.  Generates offC8.RF*/
         BPmake180CO_CO 
/*180 degree selective sinc one-lobe pulse on Ca, first null at CO.*/
      /*C13 frequency at CO.  Generates offC17.RF*/
         BPmake180Ca_Cos

/*180 degree selective sinc one-lobe pulse on CO, first null at Ca.*/
      /*C13 frequency at Ca.  Generates offC9.RF*/
         BPmake180CO_Ca
      /*C13 frequency at 35ppm.  Generates offC10.RF*/
         BPmake180COa

/*90 degree selective one-lobe pulse on H2O */
if (wexp<>'BP10')     "wexp=BP10 for autocalibrate process where" 
 then BPmakeH2Osinc   "H2Osinc.RF is made"
endif     
BPmakeH2Osinc1

/*dipsi2 decoupling pattern will be made only if not already present*/
BPmakedipsi2

/*180-degree cosine-modulated pulse on NH, leaving H2O unaffected 
(180's at +4ppm and -4ppm from H2O)*/
BPmakecosinemodulate 


         Table 10.  The BPmake90CO_Ca macro  

"Carrier on Ca, 90 degree sinc pulse on CO 118ppm away, null at Ca."
"The carrier should be set to 56ppm."

$pwC2 = 80.5*600.0/sfrq    "proper pulse width for this excitation"
                             "make maximum number of 200nsec steps"
$steps2 = $pwC2*5.0   $steps2 = 2.0*trunc($steps2/2.0) + 1.0
$pwC2 = ($steps2 + 1.0)/5.0     "find actual pulse width that fits"
$rf2 = 1023.0                           "maximum power in waveform"
BPmakesinc($steps2, $rf2) "makes a sinc pulse with correct # steps"

$stps2 = ''     
format($steps2,0,0):$stps2 "make a text piece with correct numbers"
$shape2 = 'sincs' + $stps2      "make a name using number of steps"

$freq2 = dfrq*118.0     "desired off-resonance shift in excitation" 
BPconvolute($shape2,'offC2',$pwC2,$freq2) "make phase-ramped shape"
BPmoveshape('offC2.RF')       "store shape in appropriate shapelib"

shell('rm -f',userdir+'/shapelib/'+$shape2+'.RF'):$dum
write('line3','The SLP pulse "shapelib/offC2.RF" has been created')


         Table 11.  The BPsetwurstparams macro  

/* The macro obtains decoupling channel parameters directly from the
   waveform specified, depending on the name of the pulse sequence. The
   macro BPpboxget looks in the header of the shape file to find values
   and installs them in a specific order. Variables preceded by $ are 
   not set. BPsetwurstparams is used in experiment setup macros  */ 

if ((seqfil='hbcbcgcdceheA') or (seqfil='hbcbcgcdhdA')) then
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='hbcbcacocahaA') or (seqfil='hacahbA') or 
(seqfil='noesyCA')) then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='gChsqc') or (seqfil='gChsqcP') or (seqfil='gChsqcA')) then
 if arom='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if alphaC='y' then 
   BPpboxget('wurst50.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if allC='y' then 
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if aliph='y' then 
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
endif


if (seqfil='gChmqc') then
 if arom='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if aliph='y' then 
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
endif

if ((seqfil='gCfhsqc') or (seqfil='gCfhsqcA') or 
(seqfil='CNnoesy_interintraA')) then
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='CTgChmqc') then
 if arom='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if aliph='y' then 
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
 if allC='y' then 
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif
endif
if ((seqfil='ghca_co') or (seqfil='ghca_co_n'))  then
   BPpboxget('wurst50.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='ghca_coA') or (seqfil='ghca_co_nA'))  then
   BPpboxget('wurst50.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='ghn_ca') then
   BPpboxget('cocbdec.DEC'):Cbdseq,$dmmy,Cbdpwr,$dmmy,Cbdres,Cbdmf
endif

if (seqfil='gChmqcnoesyNhsqc') then
   BPpboxget('codec.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='gNhmqcnoesyNhsqc') then
   BPpboxget('cocadec.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='gnoesyChsqcA') or (seqfil='gnoesyCNhsqcA') or
    (seqfil='gChsqcnoesyA') or (seqfil='gNhsqctocsyA') or
    (seqfil='gChsqctocsyA') or (seqfil='gtocsyChsqcA')) then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='gnoesyChsqc') or (seqfil='gnoesyCNhsqc') or 
(seqfil='gLRCC') or
    (seqfil='gChsqcnoesy') or (seqfil='gLRCH') or
    (seqfil='gNhsqctocsy') or (seqfil='gNhsqctocsyA') or
    (seqfil='gNhsqcnoesy') or (seqfil='gNhsqcnoesyA') or
    (seqfil='rna_hmqc_tocsy') or
    (seqfil='gChsqctocsy') or (seqfil='gtocsyChsqc')) then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='ghcch_tocsy') or (seqfil='ghcch_tocsySP') or 
(seqfil='hcch_tocsy') or (seqfil='hcch_tocsySP') then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='hcch_tocsyA') or (seqfil='hcch_cosyA')) then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='tnnoesy') or (seqfil='SSnoesy') or
    (seqfil='tntocsy') or (seqfil='tnroesy') or
    (seqfil='qwnoesy') or (seqfil='qwnoesyA') or
    (seqfil='tndqcosy') or (seqfil='tnmqcosy')) then 
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='wgnoesy') or (seqfil='zdipsitocsy') or
    (seqfil='wroesy') or (seqfil='wnoesy') or
    (seqfil='qwnoesy') or (seqfil='wgtocsy') or (seqfil='water')) then 
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif
if (seqfil='hcch_tocsyP') then
   BPpboxget('cctocsy.DEC'):mixpat,pwmix,mixpwr,mixpwrf,mixres,mixdmf
endif

if (seqfil='ghn_coca_cb') then
   BPpboxget('CgCO1.RF'):$dmmyshp,pwCgCO,pwCgCO_lvl
endif

if ((seqfil='rna_gChsqc') or (seqfil='rna_gCtrosy')) then
 if aromatic='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 else
 if allC='y' then 
   BPpboxget('wurst110.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 else
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif endif endif

if (seqfil='rna_gCtrosy') then
   if (aromatic_C5='y') then 
    BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
   endif
endif

if ((seqfil='rna_gnoesyChsqc') or (seqfil='rna_gnoesyChsqcA')) then
   BPpboxget('wurst140.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='rna_hcch_tocsy') then
 if AH2H8='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 else
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif endif

if ((seqfil='rna_gChmqc') or (seqfil='rna_hcch_cosy')) then
 if aromatic='y' then 
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 else
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif endif

if ((seqfil='rna_Ahnctocsyc') or (seqfil='rna_HCN') or 
(seqfil='rna_HCP'))  then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if ((seqfil='rna_CUhnccch') or (seqfil='rna_Ghnctocsyc'))  then
   BPpboxget('wurst40.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

if (seqfil='rna_ghcch_tocsy')  then
   BPpboxget('wurst80.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
endif

 if ((seqfil='rna_tnnoesy') or (seqfil='rna_wetnoesy') or
    (seqfil='rna_wettntocsy') or (seqfil='tnroesy') or 
    (seqfil='rna_tndqcosy') or (seqfil='rna_wroesy') or
    (seqfil='tnmqcosy')) then 
      BPpboxget('wurst110.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif

 if ((seqfil='wgnoesy') or (seqfil='rna_WGnoesy') or (seqfil='wnoesy')
   or (seqfil='qwnoesy') or (seqfil='wgtocsy') or (seqfil='rna_water'))
 then 
    BPpboxget('wurst110.DEC'):dseq,$dmmy,dpwr,$dmmy,dres,dmf
 endif


7.0	Updating the Probefile after a new PW90 is Determined

It is possible to update the probefile after determining a new RF calibration without doing 
a full update. The BPXupdatepw90 macros, (where X=H1,C13,N15 or H2) do an update 
of all parameters depending on the specified nucleus calibration, including re-creation of 
waveforms. These macros are detailed in Table 12.

     Table 12. BPXupdatepw90 (for X=H1,C13,N15 or H2)   

/* BPH1updatepw90: updates proton pulse parameters values in probefile.
Updates probefile with tof,tpwr,compH values in this parameter set. 
pw90 is updated to pw value and stored in probefile. finepower values 
in  probefile adjusted. ref_pw90 and ref_pwr values in probefile 
updated*/

 "read old H1pw and store in p1"
 getparam('pw90','H1'):$pw90_probefile

 "ratio of new and old pw"
 $ratio=pw/$pw90_probefile
 pw=trunc(100*pw)/100
 pw90=trunc(100*pw)/100
 ref_pw90=trunc(100*pw*compH)/100 ref_pwr=tpwr

 "load H1tpwrsf values into $tpwrsf values"
 getparam('tpwrsf','H1'):$tpwrsf_probefile
 getparam('tpwrsf_u','H1'):$tpwrsf_u_probefile
 getparam('tpwrsf_d','H1'):$tpwrsf_d_probefile
 getparam('tpwrsf_i','H1'):$tpwrsf_i_probefile
 getparam('tpwrsf_t','H1'):$tpwrsf_t_probefile
 getparam('tpwrsf_n','H1'):$tpwrsf_n_probefile

 "Calculate updated H1tpwrsf"
 $tpwrsf_probefile=trunc($tpwrsf_probefile*$ratio)
 $tpwrsf_u_probefile=trunc($tpwrsf_u_probefile*$ratio)
 $tpwrsf_d_probefile=trunc($tpwrsf_d_probefile*$ratio)
 $tpwrsf_i_probefile=trunc($tpwrsf_i_probefile*$ratio)
 $tpwrsf_t_probefile=trunc($tpwrsf_t_probefile*$ratio)
 $tpwrsf_n_probefile=trunc($tpwrsf_n_probefile*$ratio)

 getparam('finepwrf','H1'):$finepwrf_probefile

 "calculate updated H1finepwrf"
 $finepwrf_new=trunc($finepwrf_probefile*$ratio)

 $tpwrsf='' format($tpwrsf_probefile,4,1):$tpwrsf
 BPsetparams('tpwrsf',$tpwrsf,'H1')
 $tpwrsf_u='' format($tpwrsf_u_probefile,4,1):$tpwrsf_u
 BPsetparams('tpwrsf_u',$tpwrsf_u,'H1')
 $tpwrsf_d='' format($tpwrsf_d_probefile,4,1):$tpwrsf_d
 BPsetparams('tpwrsf_d',$tpwrsf_d,'H1')
 $tpwrsf_i='' format($tpwrsf_i_probefile,4,1):$tpwrsf_i
 BPsetparams('tpwrsf_i',$tpwrsf_i,'H1')
 $tpwrsf_t='' format($tpwrsf_t_probefile,4,1):$tpwrsf_t
 BPsetparams('tpwrsf_t',$tpwrsf_t,'H1')
 $tpwrsf_n='' format($tpwrsf_n_probefile,4,1):$tpwrsf_n
 BPsetparams('tpwrsf_n',$tpwrsf_n,'H1')
 $finepwrf='' format($finepwrf_new,4,1):$finepwrf
 BPsetparams('finepwrf',$finepwrf,'H1')
 $ref_pw90='' format(ref_pw90,2,2):$ref_pw90
 BPsetparams('ref_pw90',$ref_pw90,'H1')
 $ref_pwr='' format(ref_pwr,2,0):$ref_pwr
 BPsetparams('ref_pwr',$ref_pwr,'H1')
 $pw90='' format(pw90,2,2):$pw90
 BPsetparams('pp',$pw90,'H1')
 BPsetparams('pw90',$pw90,'H1')
 $tpwr='' format(tpwr,2,0):$tpwr
 BPsetparams('tpwr',$tpwr,'H1')
 BPsetparams('pplvl',$tpwr,'H1')
 $dmf=trunc(1e6/(pw*10*compH)) $dpwr=tpwr-20
 $dmfH1='' format($dmf,5,0):$dmfH1
 $dpwrH1='' format($dpwr,2,0):$dpwrH1
 BPsetparams('dmf',$dmfH1,'H1')
 BPsetparams('dpwr',$dpwrH1,'H1')
 $tofH2O='' format(tof,4,1):$tofH2O
 BPsetparams('tofH2O',$tofH2O,'H1')
 $compH='' format(compH,4,3):$compH
 BPsetparams('compH',$compH,'H1')
 BPsetparams('tpwr_cf',$compH,'H1')

 write('line3','H1 Probefile Update Finished')
 banner('H1 Probe File Parameters Updated using This pw90')


/*BP15Nupdatepw90- updates probefile values based on pwN/pwNlvl/compN. 
Updates decoupling parameters in probefile to local values*/

"calculates wurst40N.DEC and wurst80N.DEC for adiabatic decoupling." 
"These may be used in INOVA/UNITYplus having waveform generators on"
"the N15 channel, or on all VNMRS systems"

pwN=trunc(10*pwN + 0.5)/10

$dmm2=dmm2
length(dmm2):$length
substr(dmm2,$length,1):$mode  "last character shows type of modulation"

$bw = ''
$wave = ''
$name = ''
$n3=n3
format(BPdpwr2max,2,0):n3
n3=n3+'d'
$attn=n3
format(40.0*dfrq2,9,1):$bw    "set N15 decoupling bandwidth to 40 ppm "
if BPpwrlimits=1 then
  $wave = 'WURST40' + $bw + '/2.1ms'
else
  $wave = 'WURST2' + $bw + '/2.1ms'
endif
opx
setwave($wave)
pbox_rst
pboxpar('name', 'wurst40N.DEC')
pboxpar('ref_pwr', pwNlvl)
pboxpar('ref_pw90', pwN*compN)
shell('Pbox')
if BPpwrlimits=1 then
 BPpboxget('wurst40N.DEC'):$name,$par,$dpwr,$par,$par,$par
 if ($dpwr)>BPdpwr2max then
    pboxpar('attn',$attn)
    echo($attn)
    shell('Pbox')
 endif
endif
if $mode='p' then   
 BPpboxget('wurst40N.DEC'):dseq2,$par,dpwr2,$par,dres2,dmf2
endif
BPmoveshape('wurst40N.DEC')
n3=$n3
 
"calculate parameters for waltz, garp modulation"

$pwNdec=1/(4*18*dfrq2)  "pw90 for 18ppm 15N decoupling field "
ln((1e6*$pwNdec)/(compN*pwN)):$ln
$dpwr2=pwNlvl - 20.0*$ln/2.303
$dpwr2=trunc($dpwr2+0.5)
$Dmf2=trunc(1/$pwNdec)  

"  if BPpwrlimits=1, limit dpwr2 to BPdpwr2max and adjust dmf2 "
if BPpwrlimits=1 then
 if BPdpwr2max<$dpwr2 then
   ln(10):$ln10
   $exp=$ln10/20*($dpwr2-BPdpwr2max)
   exp($exp):$factor
   $Dmf2=trunc($Dmf2/$factor)
   $dpwr2=BPdpwr2max
 endif
endif

dmm2='cc'+$mode  dm2='nny'

if $mode<>'p' then   
 dpwr2=$dpwr2 dmf2=$Dmf2 dres2=1.0
endif

$compN='' format(compN,4,3):$compN
$pwN='' format(pwN,3,1):$pwN
$dmf2a='' format(dmf2,5,0):$dmf2a
$dpwr2a='' format(dpwr2,5,0):$dpwr2a
$pwNlvl='' format(pwNlvl,2,0):$pwNlvl
$dres2='' format(dres2,5,1):$dres2

BPsetparams('compN',$compN,'N15')
BPsetparams('pw90',$pwN,'N15')
BPsetparams('pwx',$pwN,'N15')
BPsetparams('pwN',$pwN,'N15')
BPsetparams('pwNlvl',$pwNlvl,'N15')
BPsetparams('tpwr',$pwNlvl,'N15')
BPsetparams('pwxlvl',$pwNlvl,'N15')
BPsetparams('pwxlvl_cf',$compN,'N15')
BPsetparams('dpwr2NH',$dpwr2a,'N15')
BPsetparams('dpwr',$dpwr2a,'N15')
BPsetparams('dmm',dmm2,'N15')
BPsetparams('dmm2NH',dmm2,'N15')
BPsetparams('dseq2',dseq2,'N15')
BPsetparams('dres2NH',$dres2,'N15')
BPsetparams('dres',$dres2,'N15')
BPsetparams('dmf2NH',$dmf2a,'N15')
BPsetparams('dmf',$dmf2a,'N15')

"create 80ppm decoupling waveform"
 $bw = ''
 $wave = ''
 $name = ''
 $n3=n3
 format(BPdpwr2max,2,0):n3
 n3=n3+'d'
 $attn=n3
 format(80.0*dfrq2,9,1):$bw   "set N15 decoupling bandwidth to 80 ppm "
 if BPpwrlimits=1 then
  $wave = 'WURST40' + $bw + '/2.1ms'
 else
  $wave = 'WURST2' + $bw + '/2.1ms'
 endif
 opx
 setwave($wave)
 pbox_rst
 pboxpar('name', 'wurst80N.DEC')
 pboxpar('ref_pwr', pwNlvl)
 pboxpar('ref_pw90', pwN*compN)
 shell('Pbox')
 if BPpwrlimits=1 then
  BPpboxget('wurst80N.DEC'):$name,$par,$dpwr,$par,$par,$par
  if ($dpwr)>BPdpwr2max then
     pboxpar('attn',$attn)
     echo($attn)
     shell('Pbox')
  endif
 endif
 BPmoveshape('wurst80N.DEC')
 n3=$n3

dmm2=$dmm2

if BPplot='off' then BPplot='' endif "reset plotter"
banner('N15 Pulse and Decoupling Probefile Parameters Updated ')

"BPC13updatepw90"
pwC=trunc(10*pwC + 0.5)/10

$pwC='' format(pwC,3,1):$pwC
$pwClvl='' format(pwClvl,2,0):$pwClvl

BPsetparams('pw90',$pwC,'C13')
BPsetparams('pwx',$pwC,'C13')
BPsetparams('pwC',$pwC,'C13')
BPsetparams('pwClvl',$pwClvl,'C13')
BPsetparams('tpwr',$pwClvl,'C13')
BPsetparams('pwxlvl',$pwClvl,'C13')

BPsetupshapes "recreate *.DEC shapes with new pwC"
banner('C13 Pulse Probefile Parameters Updated and Decoupling Shapes 
Re-created')

"BPH2updatepw90"
"takes current dpwr3/dmf3/dof3 values and updates the probefile"

   $dpwr3D='' format(dpwr3,2,0):$dpwr3D
   BPsetparams('dpwr3D',$dpwr3D,'H2')
   $dmf3D='' format(dmf3,5,1):$dmf3D
   BPsetparams('dmf3D',$dmf3D,'H2')
   $dof3D='' format(dof3,5,1):$dof3D
   BPsetparams('dof3D',$dof3D,'H2')

8.0	AutoCalibration

The above sections describe how a probefile is created and updated. It describes how 
experiments are setup using macros, and the steps involved along the way. If a user had 
to manually perform all the RF and gradient calibrations, as well as any small-angle 
phase corrections necessary for some pulse sequences, the potential for error is large, not 
to consider the time necessary for the activity. For this reason, several macros are 
provided to perform automatic RF and gradient calibrations. In addition, any small-angle 
phase shifts necessary are determined. All results are stored in the probefile and these 
results are accessed by the experiment setup macros. Since these calibrations and settings 
are used by the experiment setup macros, a full autocalibration should be done on a 
doubly-labeled (13C and 15N) protein or RNA. If such a sample is not available, 
calibrations may be performed on a 13C- or 15N-labeled compound giving a mechanism 
for obtaining all the RF and gradient calibrations. The full autocalibration method should 
be used on a doubly-labeled compound before any triple-resonance experiments utilizing 
specific small-angle phase corrections. If there is any doubt, examine the setup macro 
(same name as the pulse sequence) for any small-angle phase correction statements.

Autocalibration is performed by the BPAutoProteinCal macro (Table 14). There are 
several options available and these are passed to the macro as arguments ($1). The 
possible options are listed in Table 13.


                      Table 13   BPAutoProteinCal Options  

Option($1) specified 
   None                 Full calibration (use probefile values)
   2                    Full calibration (use current tof) 
   3                    Full calibration (use current tof,pw)
   4                    Fast Option   (RF only)
   5	1H only 
   6	N15 only
   7	C13 only

 BPBioNMR               Use BioNMR (*P.c) sequences within calibration

Full calibration is possible using all starting values obtained from the probefile ($1=0). 
Sometimes a user might have determined a new value for the H2O frequency and in this 
case this new value of tof (in the current parameter set would be used ($1=2). Similarly, 
if the user had also determined a new pw90 for 1H, the $1=3 option permits the 
calibration to use this information as the starting point. 

Full calibration results in all the RF calibrations for 1H, 13C and 15N (pw90's and 
amplifier compression factors), fine power values for various H2O selective pulses, 
small-angle phase shifts optimization for these selective pulses, gradient values for 
coherent transfer gradients in sensitivity-enhanced experiments for 13C and 15N, Bloch-
Seigert phase corrections for several sequences involving shaped pulses, 1D first 
increment spectra for a large number of double- and triple-resonance experiments and 
comparisons of intrinsic sensitivities of different pulse sequences relative to HSQC for 
the appropriate nucleus.

Once a full calibration has been performed there is usually no need for small-angle phase 
corrections, gradient values and 1D spectra to be redetermined since these are 
independent of sample. Therefore, the Fast Option ($1=4) can be used to characterize a 
new sample(perhaps after the spectrometer has been used by another operator).

If there is only a sample change and probe (1H) retuning, the 1H-only option ($1=5) is a 
fast way to redetermine the 1H pw90 and update the probefile for all parameters 
depending on the 1H pw90. Similar options for 13C and 15N ($1=6 and 7) permit 
recalibration of these nuclei and updating of relevant probefile values.

BPBioNMR is not an option of BPAutoProteinCal, but its (global) value is checked in 
determining if *P.c sequences are used instead of the *.c sequences. The BioNMR 
sequences calculate needed shapes "on-the-fly" at "go" instead of using shapes produced 
by BPcal. BPBioNMR has values of 0 and 1 and is a global variable.

There are two options for pulse sequence for the 1H and 13C calibrations: gCfhsqc and 
hcch_tocsy. The gCfhsqc has the virture of being a simple sequence, using Watergate 
3919 for water suppression and having no necessary gradient calibration. The hcch_tocsy 
is a longer sequence, but since the spinlock step is omitted during the calibration it is 
essentially an INEPT sequence. Both have the 1H and 13C transmitters on-resonance so 
there is minimal offset effect. The hcch_tocsy more closely represents the multi-pulse 
sequences used in BioPack and is the default sequence used. The gCfhsqc sequence is 
useful for first-time installations. No decoupling is used in either calibration steps, so 
only "hard-pulse" RF events are used. The gCfhsqc option is used if the global parameter 
BPquick=1. This variable is selected by a check box in the "Globals&Probefile" page of 
the Setup folder in VnmrJ.
       
                Table 14   BPAutoProteinCal   

"BPAutoProteinCal(<option>)"
" uses either hcch_tocsy (no spinlock or decoupling-essentially INEPT) 
or gCfhsqc"


$date=''
BPgetdate:$date                                     "gets current date"
BPdeuterated=0            "not used for autocalibrates (is used in 2D)"
cd(userdir)
exists('AutoTripRes','file'):$e           "backs up existing directory"
if ($e=1) then
  exists('BioPack.dir/backups','directory'):$e
  if not($e) then
    shell('mkdir -p BioPack.dir/backups'):$dum
  endif
  mv('AutoTripRes','BioPack.dir/backups/AutoTripRes_'+$date)
endif
mkdir('AutoTripRes')
$tof=tof $pw=pw
$vtset=''
shell('showstat > ',curexp+'/stat'):$dummy    "get current temperature"
lookup('file',curexp+'/stat','VT','active:','read'):$vtset,$ret
delete(curexp+'/stat')
if $ret then
  format($vtset,0,1):temp
endif

if BPquick=1 then gCfhsqc else hcch_tocsy ncyc=0 endif

if ($#>0) then  "No argument uses probefile values, full calibrate"
 if $1=2 then tof=$tof endif
 if $1=3 then tof=$tof pw=$pw endif
 if $1=4 then r7=1 endif  "For Fast RF-Only Calibration(stops at BP5d)"
 if $1=5 then r7=2 endif  "For 1H pw90 Calibration only (not compH)"
 if $1=7 then r7=7 endif  "For 1H/13C Calibration (13C-labelled cmpd)"
 if $1=6 then             "For 1H/15N Calibration (15N-labelled cmpd)" 
     gNfhsqc dm2='nnn' r7=6
 endif    
endif

if ($#>0) then  "Option calibrate"                   "Select printout"
  if $1=4 then  "Fast Option"
    if (BPBioNMR) then   "BioNMR selected"
      printon man('proteinpreface4P') printoff
    else
      printon man('proteinpreface4') printoff
    endif    "use global variable BPBioNMR as specifier"
  else           "other option"
    if (BPBioNMR) then   "BioNMR selected"
      printon man('proteinprefaceP') printoff
    else
      if ($1=5 or $1=15) then  "1H pw90-only Option"
          printon man('proteinpreface5') printoff
      elseif ($1=6 or $1=16) then
          printon man('proteinpreface6') printoff
      elseif ($1=7 or $1=17) then
          printon man('proteinpreface7') printoff
      else
          printon man('proteinpreface') printoff
      endif
    endif                   "use global variable BPBioNMR as specifier"
  endif
else   "Full calibration"
  if (BPBioNMR) then                                  "BioNMR selected"
    printon man('proteinprefaceP') printoff
  else
    printon man('proteinpreface') printoff
  endif                     "use global variable BPBioNMR as specifier"
endif

if (seqfil='gNfhsqc') then
   wnt='wft select(1) setref sp=6p wp=4p vsadj(50) dssh'
else
   dm='nnn' 
   wnt='wft select(1) setref sp=-1p wp=4p vsadj(50) dssh'
endif

ni=0 phase=1 
pw=trunc(10*pw + 0.5)/10 "ensures pw is multiple of 100nsec"
nt=2 array('pw',15,pw-0.35*pw,0.05*pw)
f ss=4 ssfilter=500 ssntaps=200 ssorder='n' full av
vp=0 cdc f fn=4*np 
wexp='BP1'
spin='n'
au

The full AutoCalibration process is performed at least once immediately after installation 
and a probefile update. This ensures that all necessary calibrations are performed. It does 
require a doubly-labelled sample. If one is not available, the 13C or 15N options above 
should be used. No triple-resonance experiments involving small-angle phase corrections 
should be done until this full calibration is performed.
 
9.0	2H AutoCalibration

2H decoupling during a pulse sequence is often desirable, particularly for large 
deuterated proteins. The hardware necessary to do this is typically a broadband channel 4 
or a lock/decoupler(INOVA, UNITYplus). In some cases channel 3 might be used. There 
are macros provided for all of these hardware cases. In each case, the 2H present in the 
solvent (typically D2O) provides a strong 2H signal via direct observe using the 
decoupling channel. Here, a single pulse is delivered via the decoupling channel using the 
same RF path used for decoupling. The signal is detected using the same RF path used 
for 2H observe for gradient shimming. For INOVA/UNITYplus, only one cable change is 
necessary to fully automate this calibration. No cable change is necessary for the Varian 
NMR System. Fortunately, the double-tuned 1H/2H coil is so heavily weighted toward 
1H that the 2H calibration is insensitive to sample so the calibration need not be done as 
often as for 1H. 

Any necessary cable change is described in the manual pages and these can be displayed 
by clicking the proper menu button (VNMR) or by clicking the "Instructions" button 
(VnmrJ). In both cases the file is displayed in the text window.

In VNMR the user navigates the menu: 
Main...Setup...Proteins...Calibrate...Other...Deuterium...Direct Detection using 2H 
Obs...Instructions. 

In VnmrJ the user selects the "Calibrations" page within the Setup folder. The 
"Instructions" button is displayed within the 2H AutoCalibration group.

In both cases there will be displayed directions for any required cable change. This would 
involve moving the decoupling channel RF amplifier output (thick cable) from the top to 
the bottom of the K5022 RF relay at the back of the box near the magnet. The cable 
normally attached at the bottom is left unattached. Once this cable is moved the 
decoupling channel RF will be routed to the lock coil, and yet 2H observe (tn='lk') is still 
active. Remember to restore the cables to normal position after the calibration is 
complete. This is not necessary for the newer VNMRS console.

The process is initiated by using the proper button for the RF channel to be used for 
decoupling (In VNMR use the menu button "Direct 2H (channel 3(4,lock/decoupler)" or 
in VnmrJ use the relevant button in the "Calibrations" page within the Setup folder.

The autocalibration consists of an experiment to find the 2H signal, and then for a fixed 
pulse width, the power level is varied. After the signal goes through a maximum the 
experiment is automatically stopped and a pulse width array spanning the expected 
pw360 is set up at the power giving the maximum signal. The null spectrum in this new 
experiment gives pw360. Then a macro updates the probefile with dpwr3 and dmf3 based 
on an appropriate decoupling bandwidth. In addition, the dof3 probefile value is updated 
and set to 2.5ppm in the 2H spectum. Henceforth, any experiment setup macro for an 
experiment potentially involving 2H decoupling obtains calibrated values for these 
parameters so 2H decoupling is obtainable by just setting dm3='nyn' (see pulse 
sequences for details. dm3 is used only as a flag and is not using the normal "status" 
control.) 

Calibration via Indirect 2H Detection using 13C Observe:

A pulse sequence (*ddec_pwxcal.c) is supplied that can be used on a C6D6 or CDCl3 
sample. Cable the probe for C13 observe and connect the channel 4 output to the 2H 
Decoupling Accessory (diplexer box). Connect the lock cable normally connected to the 
probe to the same box, and connect the box to the probe at the lock BNC. Use the 2H 
reject filter and low-pass filter at the BB preamp.

Use the menu buttons (VNMR 6.1) or dropdown menu (VnmrJ) for parameters. Adjust
The C13 pw to the value of a 90 degree pulse and any other appropriate parameters.
The C6D6 or CDCl3 triplet exhibits a nulling with increasing pw(2H), but the outer lines 
null at a longer time than the inner lines. Use the outer lines to find a null and this occurs 
at pw90 (2H).  Use this value to determine dmf3 (dmf3=1e6/pw90) at the power dpwr3. 

While it may seem that this method is more suitable (since the purpose of 2H decoupling 
is to decouple 2H from 13C) the above method is more reliable and far easier to use. It 
has the advantage of calibrating on the protein sample itself, rather than using an organic 
solvent.

Control of 2H Decoupling in Pulse Sequences

Deuterium decoupling is optional for spectrometers having 4 channels and may be 
applied in triple-resonance experiments while CaCb magnetization is transverse, and 
during any 1H shift evolution, for many BioPack sequences (ghn_co which does not 
generate transverse CaCb magnetization).  

Note that 2H decoupling is done via dm3='nyn'. No status(B) statement is present in the 
pulse sequences but dm3 is just used as a flag to call the setstatus statement. All the 
normal decoupling parameters such as dpwr3, dof3, dmm3, dmf3 etc. are active, 
however, and should be set properly. The 2H Decoupling Accessory should be used to 
couple in Channel 4 and the Lock to the lock circuitry of the probe.  The parameter 
"ampmode" should be set to 'dddp' when 2H decoupling is used with a BB 4th channel. If 
a lock/decoupler is used, ampmode='dddd'.  This parameter is present and is set by the 
macro BPsetampmode for all parameter sets having 2H decoupling as an option.

The 2H magnetization is preserved in all sequences except hcch_tocsy and ghcch_tocsy. 
In the latter cases disturbance of the lock signal may be observed. In sequences where 
preservation of 2H magnetization is achieved, trim gradients around refocusing pulses are 
switched off during the 2H decoupling, so additional artifacts are possible.

Testing 2H Decoupling

The parameter set *ddec_s2pul.par uses the pulse sequence *ddec_s2pul.c (s2pul.c with 
amplifier unblanking and lock sample/hold for channel 4's amp). You can verify the 
proper dof3 value by adjusting the dof3 array values so that the results are symmetric 
with respect to dof3. This means that the center value of dof3 corresponds to ~7ppm in 
the 2H spectrum(shift of CDCl3 or C6D6). The dpwr3 and corresponding dmf3 should be 
large enough to cover ~7-8ppm , with dof3 set at 3ppm in the 2H spectrum. (It 
is not necessary to decouple over the full 10ppm range since 2H decoupling is usually 
used to decouple only aliphatic deuterons). Once you have set the 2H calibrations you 
can then check the decoupling efficiency using your values of dpwr3, dmf3 and dof3.

If the 2H channel on the probe has been retuned, or if calibrations are done manually, the 
probefile should be updated using the BPbiopack2 or BPH2updatepw90 macros (via 
buttons) to update the channel 4 parameters. No change in parameters should be 
necessary from sample to sample.

2H broadband decoupling is handled internally within the pulse sequences by the 
"setstatus" psg command, not by the usual "status" approach. Thus, "dps" and "pps" show 
only status A and C. The dm3 parameter is only used to determine that decoupling is 
desired during relevant portions of the pulse sequence and is requested by setting 
dm3='nyn'. Use of the normal status approach will result in other channels being reset to 
their status values, since all channels are set at the same time by any change in status on 
any channel. Hence, C13 decoupling that is initiated by waveform psg commands 
(decprgon) at an earlier time would be turned off since dm='n' when there would be a 
normal status change on any other channel.

10.0	  Power Limits and the ampmode parameter

The BPpwrlimits parameter (a global variable) has possible values of 0 and 1. If the value 
is 1 several macros will act accordingly, checking for possible power limit violations. 
These can arise if a decoupling waveform generated that requires a power in excess of the 
limit or if a power level is explicitly set. The power limits are not encoded into system-
level software or pulse sequences and are only checked when the probefile is updated or 
an experiment setup macro is run. Each of the first three channels has a global parameter: 
BPtpwrmax, BPdpwrmax and BPdpwr2max and these are displayed in the "Decoupling" 
tcl/tk panels (for VNMR) or the "Globals and Settings" page within the VnmrJ Setup 
folder.  The first macro, BPcheck, is called when an experiment setup macro is run (at the 
end of BPrtppar) and is described in Table 15.

               Table 15   The BPcheck macro   

" BPcheck "
"This is a macro that will run before every BPsvp"
"and after every BPrtppar"

if BPpwrlimits=1 then                        "Power limits are desired"
 if (tpwr>BPtpwrmax) then            "only for case of too much power"
    ln(10):$ln10    "this section figures out new pw90 for lower power" 
    $exp=$ln10/20*(tpwr-BPtpwrmax)
    exp($exp):$factor     
    pw90=pw90*$factor
    tpwr=BPtpwrmax       "tpwr is now set to user-defined power limit"
 endif
 if (dpwr>BPdpwrmax) then            "only for case of too much power"
  if ((dmm<>'ccp')or(dmm<>'cccp')or(dmm<>'cpcp'))  "only for non-
waveform modulation (waveform operation handled by BPsetupshapes"
   then
    ln(10):$ln10
    $exp=$ln10/20*(dpwr-BPdpwrmax)
    exp($exp):$factor
    dmf=dmf/$factor
    dpwr=BPdpwrmax
  endif
 endif
 if dpwr2>BPdpwr2max then            "only for case of too much power"
  if ((dmm2<>'ccp')or(dmm2<>'cccp')or(dmm2<>'cpcp'))  "only for non-
waveform modulation"
   then
    ln(10):$ln10
    $exp=$ln10/20*(dpwr2-BPdpwr2max)
    exp($exp):$factor
    dmf2=dmf2/$factor
    dpwr2=BPdpwr2max
  endif
 endif
endif

The macros BPcheckdpwr and BPcheckdpwr2 perform similar operations and are used within 
experiment setup macros for different decoupling conditions.


Amplifiers can operate in either "pulsed" (blanked) mode or "cw" (unblanked) mode. The 
ampmode parameter, if existing, allows overriding of default conditions. Normally this is 
unnecessary for 1H, 13C and 15N, but 2H must be treated differently because of potential 
interference with lock performance. Normally the ampmode parameter does not exist in a 
parameter set. If must be created and set properly for 2H decoupling. The BPsetampmode (Table 
16) macro is used for this purpose. It is called in the experiment setup macros for those sequences 
having programmed 2H decoupling. In the VNMRS system, amplifiers are automatically blanked 
if unused.


                      Table 16.  The BPsetampmode macro   

" BPsetampmode "
if (numrfch>3) then                  "only relevant for 4 channels"
  exists('ampmode','parameter'):$e
  if $e=0 then create('ampmode','string') endif
  substr(rftype,4,1):$ddec             "figure out type of channel"
  if $ddec='l' then                   "Channel 4 is lock/decoupler"
    dn3='H2'                   "Channel 4 is set for lock normally"
    ampmode='dddd'            "use default mode for lock/decoupler"
  else
    dn3=''                   "Disable Channel 4 except when needed"
    ampmode='dddp'             "use pulsed mode for normal channel"
  endif
else
  exists('ampmode','parameter'):$e             "ampmode not needed"
  if $e=1 then destroy('ampmode') endif
endif

exists('reffrq','parameter'):$e
if ($e=0) then create('reffrq','real') endif
reffrq=sfrq

The lock/decoupler can only be in one state or the other. Therefore it cannot affect the lock and 
the amplifier can be in a default mode. However, a broadband channel needs to have the amplifier 
in the "pulsed" or "blanked" mode to prevent noise from being picked up in the lock preamp. The 
name "pulsed" does not mean that only pulses can be applied, it just refers to the blanking mode.

If a "normal" broadband channel is used for 2H decoupling, the user must set dn3='H2' and 
dm3='nyn' after running the experiment setup macro. Use "dps" to verify activity on channel 4. 
If the 2H AutoCalibration was performed previously, the dpwr/dmf/dres parameters will be 
automatically set, leaving only dn3 and dm3 to be set.



11.0	  Understanding Automated Operations

The above sections describe many of the important macros used in seting up of 
experiments, their execution and the use of the probefile. Autocalibration, Auto1D, 
Auto2D and sequence-specific automated operations all use the same basic construct: the 
experiment is begun with the "au" command. This command is an alias of "go" but will 
execute any text string present in the wexp, wnt, wbs and werr parameters. These 
parameters are visible in the VNMR tcl/tk panels "Flags and Cond." And in the VnmrJ 
"Future Actions" page within the Acquire folder.

All automated experiments have setup macros that set the value of wexp. Often, wnt is 
set to show updated spectral displays during the acquisition of an array. Experiments can
be halted  during an acquisition and another Experiment joined without any problem, as 
long as the the original experiment is restarted by "au" (the wexp/wnt values are still the 
same). If there is a problem with something failing it can be diagnosed by determining 
when the failure occurred. If the wexp macro fails, the data is still present and a new "wft 
dssh" will show the data. Since the data is present the failure must be within the 
execution of the macro specified by wexp. Sometimes, just looking at the data manually 
will reveal the source of the problem. If the spectral intensities should rise and fall as a 
function of the arrayed parameter, but steadily rise or fall, the wexp may fail or determine 
an incorrect value within its execution. The proper strategy is to examine the failed data 
set, determine the macro to be executed by wexp and then look at that macro. Examine its 
operation step-by-step. Sometimes parts of the macro will execute and  evidence of this 
gives a clue to the failure point. Error messages are often given to help in the diagnosis. 

Autocalibration operations usually generate plots containing parameter tables. These can 
be examined for the values of wexp so that the operative macro is known.  If a failure 
occurs, examine that last plotted spectrum. Look for the value of wexp and read that 
macro. It will have a line containing BPsvf which is the macro saving the data. This gives 
the name of the fid that then can be recalled with "rt". The data can then be processed 
manually. If a value of "wnt" is specified in the recalled data, the command "{wnt}" will 
execute the contents of wnt. If the data look normal, execute the command "{wexp}" 
which will execute the contents of wexp. This should allow you to view the error 
condition and take appropriate steps.

Automatic plotting can be disabled by setting the global parameter BPplot to 'off'.
Plots may be also made directly to a file (BPplot='file'), as described in the BPpage 
macro below.


" BPpage - utility macro for plotting / saving plots to file(s) "

exists('BPplot','parameter','global'):$eplot
if not($eplot) then
  page
else
  if BPplot='off' then
    page('clear')
  elseif BPplot='file' then
    $plotdir=''
    exists('BPplotdir','parameter','global'):$eplotdir
    if $eplotdir then
      $ch1=''
      substr(BPplotdir,1,1):$ch1
      if $ch1='/' then
	$plotdir=BPplotdir
      elseif BPplotdir<>'' then
	shell('dirname',userdir):$plotdir
	$plotdir=$plotdir+'/'+BPplotdir
      endif
    endif
    if $plotdir='' then
      shell('dirname',userdir):$plotdir
      $plotdir=$plotdir+'/BPplots'
    endif
    exists($plotdir,'directory'):$e
    if not($e) then
      shell('mkdir -p',$plotdir):$dummy
    endif
    exists($plotdir,'file','rwx'):$e
    if not($e) then
      write('error','Unable to create plot dir %s',$plotdir)
      shell('dirname',userdir):$plotdir
      $plotdir=$plotdir+'/BPplots'
      shell('mkdir -p',$plotdir):$dummy
      write('line3','Saving BioPack plots in %s',$plotdir)
    endif
    $numfile=$plotdir+'/BPplotnum'
    $plotnumstr='' $plotnum=0
    exists($numfile,'file'):$e
    if $e then
      shell('cat',$numfile):$plotnumstr
      format($plotnumstr,'isreal'):$r
      if not($r) then
        $plotnumstr=''
      else
        format($plotnumstr,'lower'):$plotnum
        $plotnum=$plotnum+1
        format($plotnum,'04',0):$plotnumstr
        length($plotnumstr):$len
        while $len<4 do
          $plotnumstr='0'+$plotnumstr
          $len=$len+1
        endwhile
	shell('rm -f',$numfile):$dum
        write('file',$numfile,'%d',$plotnum)
      endif
    endif
    if $plotnumstr='' then
      $plotnum=1
      $plotnumstr='0001'
      shell('echo 1 >',$numfile):$dummy
    endif

    " determine plot output language "
    $pltt=''
    plotinfo(plotter):$pltt
    lookup('file','/vnmr/devicetable','seek','Example','readline',2)
    $devtype='' $res=1
    while ($devtype<>$pltt) and ($res=1) do
      lookup('seek','PrinterType','read'):$devtype,$res
    endwhile
    $ext=''
    if $devtype=$pltt then
      $raster=''
      lookup('seek','raster','read'):$raster
      if $raster='0' then
	$ext='.pgl'
      elseif ($raster='3')or($raster='4') then
        $ext='.ps'
      endif
    endif

   " For now we use an automatic name template '%date%_%%_%seqfil%' - "
   " we may add parameter / name template control later "
    $plotfile=''
    shell('date "+%Y-%m-%d"'):$plotfile
    $plotfile=$plotfile+'_'+$plotnumstr+'_'+seqfil+$ext
    $plotfile=$plotdir+'/'+$plotfile
    page($plotfile)
    write('line3','Plot written  to file %s',$plotfile)
  else
    page
  endif
endif

12.0	  Experiments Performed During AutoCalibration

The above sections describe in general the experiment setup philosophy and important 
macros used to manage the probefile. In this section we will cover the actual experiments 
used for AutoCalibration.

Since a doubly-labeled compound (typ. ~1mM in 90% H2O) will be used, pulse 
sequences are selected that produce single-transient spectra that do not need to be phase-
cycled. This means that, apart from the residual water signal, larger signal intensity 
indicates a more suitable value for a parameter when the parameter is arrayed. This will 
be the case for all experiments used in this process. Data are stored in the AutoTripRes 
directory in the user's vnmrsys (any existing directory is moved to the BioPack.dir 
directory). Each experiment is stored for future examination. Data are processed and 
plotted as part of the AutoCalibration.

1H, 13C and 15N RF Calibrations
The first experiment set up by default is hcch_tocsy. While normally this involves a 13C 
spinlock, this is disabled and 13C decoupling is turned off. Therefore, the experiment is 
essentially a 13C HSQC. This pulse sequence is used because the 13C transmitter is set in 
the aliphatic region and therefore resonance offset effects are small (calibrating 13C 
pulses that are off-resonance will lead to errors, particularly at high field or when pwC 
values are >10-15usec). The 1H resonance offset effect is small enough to be ignored for 
pw<10usec. An alternative sequence, gCfhsqc (a 3919 watergate 13C HSQC), is used if 
BPquick=1 (selected by a checkbox in the "Globals&Probefile" page in the Setup folder.

The BPAutoProteinCal macro sets up the experiment using the calibrations and settings 
found in the active probefile and then sets up a pw (1H) array of 15 values centered 
around the probefile pw value. It then sets wexp='BP1' and begins the experiment with 
the "au" command. At the completion of the experiment the BP1 macro executes and the 
data plotted. The macro measures the peak height of the tallest peak upfield from the 
water and uses this pw to set up a new array with smaller step sizes. After this new 
experiment runs, the BP2 macro does the same analysis and stores the value in the pw90 
parameter. The power is then dropped 12dB and a new 90-degree pulse is determined 
(BP2a and BP2b) in the same manner. The ratio of this new pw90 and the one at higher 
power permits calculation of compH, the amplifier compression factor for 1H.

This factor should be 1.000 under ideal conditions. However, if the tpwr value is near the 
top of the range, depending on the amplifier, there may be some "compression" of the 
amplitude, leading to a longer pw90 at the higher power than would be calculated (12dB 
should mean a factor of 4 in pulse width). For example, if the pw90 at higher power was 
6usec and at lower power it was 20, the compression factor would be 20/(4*6), or 0.83. A 
perfect amplifier would have pw90 at high power be 5usec (the lower power is usually a 
safer and more accurate power for calibration purposes). For any channel, once 
compression factors are determined they do not change as a function of sample if the 
same power values are used.

Following the above experiments, pwC (the 13C pw90) is arrayed around the probefile 
value over a large range (for example, from 6-28usec). A usuable probe will have pwC 
fall within this range, and a signal maximum will occur near the correct pwC value. 
Again, this new value is used as the center of a new pwC array with smaller step size and 
the best value in this new experiment is "memorized" and stored in the parameter set 
(macros BP3 and BP4).

Some pulse sequences involving simultaneous 13C and 15N pulses automatically drop 
powers on these channels 3dB for probe protection. Therefore, pwC is then arrayed at this 
new power, a maximum found, and a new array with smaller step size performed (macros 
BP4aa and BP4aaa).  An estimate of the 13C amplifier compression factor, compC , is 
also determined.

At this point the gNfhsqc experiment is set up and a pwN array set up around the 
probefile value for pwN. This pulse sequence is used because it only depends on pw and 
pwN to give signal and does not depend on a gradient calibration. It uses watergate 3919 
which uses "hard" pulses so no additional calibration is necessary. Macros BP6 and BP6a 
are used to determine pwN and the probefile pwNlvl value and also at a power 6dB lower 
in order to calculate the compression factor for the 15N amplifier, compN. This value of 
compN is used for accurate calculation of decoupling parameters for 15N.


Selective Pulses on H2O

Many experiments use selective 90-degree pulses on the H2O. These are used to preserve 
water magnetization along the +Z-axis so that exchangeable NH protons are not partially 
saturated. No presaturation is used typically so water magnetization is aligned along +Z 
at the end of the relaxation delay. While pulses within the pulse sequence do affect the 
water magnetization, in most cases (a "water-friendly" sequence) the water magnetization 
is restored to +Z as soon as possible, and certainly before acquisition. This not only 
preserves the magnetization but minimizes the detected water signal.

Different pulse sequences use different selective pulses, because the type of phase control 
used is different (examine the pulse sequence code or use "dps" to see how the selective 
pulses are used). For this reason, five different selective pulse types are used, and five 
different shaped pulse files must be created. This is done in the AutoCalibrate process. 
The pulse sequence (flipback_cal) has different options for different cases (governed by 
the satmode parameter). Each shaped pulse can be phase-corrected within the sequence 
and fine power adjustment is also possible. A satmode value of "i","t" or "n" produces a 
soft pulse immediately following an 1H-15N INEPT transfer (often used in the ghn* and 
gNhsqc sequences) followed by acquisition. A satmode value of "u" produces a "hard" 
pw90 followed by a "flip-up" selective pulse. A satmode value of "d" produces a "flip-
down" selective pulse followed by a "hard" pw90. In all cases the water signal is 
monitored. Minimum water signal indicates the most +Z H2O magnetization.  The pulses 
are listed in table 17.

                                 Table 17. Selective Pulses on H2O

                  Satmode                    Nature of the Pulse          Shape Created

                     i                     following an INEPT                   H2Osinc_i.RF
                     t                     in ghn* TROSY's, gNhsqc        H2Osinc_t.RF
                     u                    following an hard 90                  H2Osinc_u.RF
                     d                    prior to a hard 90                        H2Osinc_d.RF
                     n                    in gNhsqc TROSY                     H2Osinc_n.RF

The macro BP6a sets up the flipback_cal experiments as a triple array: satmode, phincr 
and tpwrsf, and uses the H2Osinc.RF shape which is a "standard" shape already created 
by the BPcal macro in the probefile update. This pulse has no phase correction within the 
shape. For each value of satmode (pulse sequence type), the fine power is varied around 
the value of 2000 (the coarse attenuator value is calculated within the pulse sequence 
from tpwr/pw/compH). The phincr phase correction parameter is set to a constant value.
At the end of the experiment the BP4a macro determines the optimal fine powers by 
looking for the minimum water signals. It then sets up a new array for each type of 
selective pulse, using the just-determined fine powers for each, but varying the phincr 
parameter from +60 to -60 degrees. After this data set is acquired, the BP4a1 macro 
determines the best phincr values for each shape and calls Pbox to create new versions of 
the shapes (listed in Table 17) that incorporate the phase shift into the pulse shape itself. 
This means that the shapes can be used in any sequence without needing small-angle 
phase correction statements. 

As a final optimization, the fine power is re-arrayed for each of the newly-created shape 
files. At the end of this experiment the BP4b2 macro determines the best fine power for 
each of the shapes and updates the probefile with these values. 

At low field and/or with a low-Q probe, these power values will be very similar because 
it is radiation damping that is responsible for the variation. Radiation damping will tend 
to restore the water magnetization to +Z and can operate in milliseconds at very high 
field. Use of a high-Q probe also enhances this effect. Thus, it takes more power to do a 
"flip-down" pulse than predicted. Conversely, it takes less power to do a "flip-up" pulse. 
Therefore, the fine power optimization can produce values differing by 50% and this 
calibration is very important in these.

Separate flipback pulse optimization is also available. A menu button (VNMR) or panel 
button (VnmrJ) can run just this section, calibrating the flipback pulses and creating 
shapes, even on an unlabeled sample (in H2O). 

NH Coherence Transfer Gradients

Many experiments use gradients in lieu of phase-cycling to select specific magnetization. 
The experiments that detect NH protons can use 1H and 15N pulses along with a gradient 
pair having amplitude/time ratios set to refocus NH magnetization and diphase all others. 
The next experiment is set up by the BP4b2 macro and uses the ghn_co pulse sequence. 
All information necessary to do this experiment has now been determined, except for the 
gradient amplitude ratio. So a gzlvl2 array is set up around the probefile value and the 
BP5 macro analyzes the acquired data to determine the optimal value of gzlvl2.  It is 
refined in a new array with smaller steps and the BP5a macro obtains the best gzlvl2 
value. Following this, a compC array is set up around the probefile value. All 13C pulses 
in this pulse sequence have compC involved in determining their amplitudes, so varying 
compC directly produces a simple means for optimizing this parameter (macros BP5c and 
BP5d). 


HSQC's

Following the above, a gNhsqc experiment is set up, now using the gzlvl2 value 
determined above, and a double array of d1 and nt is set. Three spectra are obtained for 
d1=.4 nt=16, d1=1 nt=8 and d1=2.1 nt=4. Each experiment takes the same time so the 
BP7a macro can analyze for best s/n to determine the best d1 value to use in subsequent 
experiments.

The gNhsqc pulse sequence has an option for NH2-only, so the BP7a macro sets up 
NH2only='y','n' and the resulting data is processed by the BP8 macro, showing NH2-
only data as well as NH /NH2 1D data.

At this point the BP8 macro sets up the gChsqc experiment for the option SE='y' 
(sensitivity enhanced). This option uses a gradient pair for refocusing CH magnetization 
and this gradient level is arrayed. The resulting spectra are analyzed by the BP8a macro 
for the best gzlvl2 value and the probefile updated. (This same optimization is later done 
using the ghcch_tocsy pulse sequence). Then, six 1D spectra are taken for the cases of 
detecting protons attached to "all carbons", "aliphatic carbons only", "aliphatic CH2's", 
"alpha carbons only", "alpha carbon CH2's" and "aromatic carbons".
Probefile Update

Following the above calibrations, the ghn_co experiment is set up with the new 
calibrations and then the macro BPbiopack2 is executed (see above). The probefile is 
fully updated and all waveforms are recalculated using the new pulse calibrations. All 
decoupling power levels etc. are updated at the same time, for both 13C and 15N. 

First Increment Spectra from Triple-Resonance Experiments

The next part of the process is to collect a variety of first increment (ni=1 ni2=1) spectra 
under identical conditions (gain, sw, nt, at, ...). The spectra are plotted with parameter 
sets, pulse sequences and scales.  These data provide the input for the side-by-side 
comparison plotted at the end of the process.

Small-Angle Phase Shifts

Several sequences use small-angle phase shifts prior to certain pulses on 13C. This is to 
accommodate a "Bloch-Seigert" phase shift induced by the use of band-selective pulses. 
This correction may be avoided by using pairs of band-selective pulses, but this adds 
complexity and length to a pulse sequence. The amount of correction is determined by 
the frequency (magnet) and is, to first-order, taken care of in the pulse sequnce code. 
However, a user-determined shift is provided, and this is calibrated by varying the phase 
shift to obtain a maximum signal for ni=1 or ni2=1 or, alternatively,  a minimum signal, 
followed by subtraction of 90 degrees. After the phase shift is determined the value is 
stored in the probefile. Any experiment using these values has part of the setup macro 
accessing the probefile value.

Experiment "Receptivity" Plot

The final plots are side-by-side comparisons of intrinsic pulse sequence "sensitivity" for 
the sample used. The N15 HSQC data is scaled to 150mm and the resulting vertical scale 
(vs) is used on subsequent NH-detected plots. Since all spectra were obtained using the 
same gain and nt values, this plot permits the user to assess the relative sensitivities. 
These vary because of losses from relaxation (T2) and are most severe for those 
sequences that have the desired magnetization spending more time in the backbone 
carbon framework. A similar plot of CH-detected data is made using the 13C HSQC as a 
base.

The final printout is a report showing the probefile and stored calibrations and settings.

Offsets for RNA and DNA

The spectral widths provided are adequate for 600 MHz so they can be scaled to your 
sfrq. The value of dof2 (N15) should be 200 ppm for all experiments. All dof (C13) 
values are 110ppm. These are changed appropriately in the psglib code for the specific 
pulse sequences 

It is not necessary to use an RNA or DNA sample for AutoCalibration. A dilabeled 
protein sample can be used. RNA and DNA sequences use the same parameters as used 
by the protein experiments. Only spectral widths and offsets are different and these are 
handled by the experiment setup macros.


13.0	  Auto1D and Auto2D

One of the useful features of the full AutoCalibration is the comparison of "receptivities" 
of a given sample to different pulse sequences (see above). If a full AutoCalibration has 
been done recently enough no 13C, 15N, or gradient calibration is likely to have changed. 
The probe is usually retuned for a new sample so that the 1H calibration may change 
(along with any related calibrations such as H2O selective pulses). If a "receptivity plot" 
is desired, but without the time necessary for calibrations, the Auto1D option may be 
selected.  This has an option for first determining the 1H pw90 followed by a series of 
first increment spectra and the "receptivity" plots. Thus, a new sample can be rapidly 
screened for sensitivity. All data acquired are stored in the user's 
vnmrsys/AutoTripRes1D directory. As in the case of the full autocalibration, any existing 
AutoTripRes1D file is backed up in the BioPack.dir directory present in the user's 
vnmrsys prior to a new run.

Given that a new sample has been through an autocalibration, the Auto2D options permit 
a user to survey 2D "receptivities" as well. In this case the nature of the 2D spectra is of 
interest, perhaps indicating the relaxation or aggregation properties of the sample. Upon 
selecting the option, at the end of the series of 2D acquisitions the data can be 
automatically processed and plotted. By adjusting the d1 delay, options are available for 
4,8 and 16 hour runs. This is automatically done by selecting a button for a  4-, 8- or 16-
hour run. In all cases, the ni and ni2 values are pre-selected to provide adequate 
resolution. The nt values are pre-selected based on the relative sensitivities of the 
experiments. The automatic processing is provided for as a convenience to the user. 
Individual data sets can be manually processed to reveal the full quality of the data.

14.0	  Understanding What Happens "at the Click of a Button"

The most direct and easy way to perform all the above operations is to use the menu 
buttons (for VNMR). VnmrJ offers much more "obvious" control in the "Globals and 
Probefile" and "Calibrations" Setup pages through the use of entry boxes, displayed 
parameter values (textmessages), checkboxes and buttons. There are similar controls in 
the VNMR tcl/tk "dg" panels. VnmrJ substantially expands the use of "obvious" control 
elements and has many more pages to contain them. This leads to the ability to run all 
BioMolecular NMR experiments without recourse to a command line.

For those needing to go beyond this interface and find out what is actually done when a 
button is clicked or an entry box filled in, the panel or page editors are useful. In VNMR 
there is a tcl/tk editor that is activated by holding down the "control" key and clicking the 
desired tab at the right. Two popup windows are generated. The first is a "cell-based" 
window that shows how the tcl/tk window is broken up. Clicking on a cell makes the 
second window show the details, including vnmr variables, commands and macros. This 
should be the first step in getting an understanding. 

There is a similar editor for VnmrJ. This is activated by the Edit function of the 
MainMenu (top line in the VnmrJ display). Use the Parameter Panel selection and a 
popup will appear. Double-clicking on the widget of interest will show the details in the 
popup. 

In either case, the underlying macro (in most cases) is displayed and it can then be read 
and understood using any editor program. These interfaces can be customized by the user 
to add new buttons or other widgets in order to run user-created macros, adding to the 
usability of the interface.
  
15.0	  How to Add a New Experiment into BioPack

BioMolecular NMR experiments require, at a minimum, a compiled pulse sequence and 
an appropriate parameter set that includes all parameters used by the pulse sequence. In 
principle, it is not even necessary for the user to be able to view the values of parameters 
for the experiment to function. Of course, this is not acceptable, so visual displays are 
necessary to review the parameter values before beginning the experiment. While it is 
possible to just do an ordinary "rtp" to install the parameter set into the current 
Experiment, Section 5.0 above clearly demonstrates the power of using a setup macro. 
Many, if not most, Biomolecular experiments use one or more shaped pulses and 
waveform-based decoupling shapes. These need to be supplied or created if not done by 
the sequence itself.

#1. Prepare an Experiment Setup Macro
Section 5.0 illustrated the syntax and structure of a setup macro. These can be very 
simple or more elaborate, depending on the operations desired (and predictable). The 
general philosophy is to begin with BPrtppar, which calibrates the newly-setup parameter 
set from values in the probefile (used or not). Then parameters specific to the pulse 
sequence are set, followed by settings of parameters and initializations. Any new 
sequence added to BioPack should be written in a BioPack parameterization, if possible. 
However, the AutoCal approach (*A.c sequences) permit non-BioPack style sequences to 
be run as if they were. Normally, the setup macro has the same name as the C code, but 
without the ".c" at the end.


#2. Prepare a Parameter Set
The simplest way to start is to set up a related BioPack sequence or one that has the same 
number of dimensions and is of similar complexity in channels and gradients. This means 
that most of the parameters you need will already be present. Then set seqfil to the name 
of the new sequence. You should modify the text file in the parameter set appropriately. 
Next, any new parameters needed but not present need to be created using the "create" 
command. A fast way to check for completeness is to run "dps" with a text window open. 
Missing parameters will be listed. Next, the new parameters should be displayable.

The oldest display of parameters is the "dg"-style of text output. The display is static, but 
is updated by VNMR/VnmrJ as appropriate. Not all parameters need to be present in the 
"dg" panels, but important parameters should be visible. The command "paramvi('dg')" 
permits the user to edit the "dg" parameter to add new parameters. There always is a "dg" 
parameter in the parameter set (in the "procpar" file) and this parameter can be modified 
by the editing process. Analogously, the "ap" parameter should be edited in the same way 
for the printed parameter table.There is an "edit" button in the "Text Out" page of the 
Setup folder for editing "ap".

 New pulse sequence parameter sets should always have a proper "dg" family and "ap" 
parameters for useful and accurate display and reporting. After editing these files the 
parameter set should be saved to disk to avoid future need to repeat the editing. (The 
"dg"-style of display involves parameter names and values, but not descriptive "NMR 
language" phrases that can appear on buttons or next to entry boxes. These capabilities 
are present in the tcl/tk (VNMR) and java xml (VnmrJ) panels.)

 #3 Prepare a Help File
New experiments should have a "manual" file present in either /vnmr/manual or 
~/vnmrsys/manual. This text file is often the top part of a pulse sequence showing any 
comments provided by the author and gives suggestions as to parameter values, 
processing information and other points peculiar to the pulse sequence. This file usually 
has the same name as the sequence (without the ".c") and is displayed in the text window 
by the "man('name')" command. This command is often used within an experiment setup 
macro. It is available via button in the Text Output Page of the Acquire folder in VnmrJ.

#4 Modify the Experiment Selection Menu
The user should not have to use the command line to set up the experiment. This means 
that the programmable menu in VNMR or the drop-down menu in VnmrJ should be 
edited to include a function to run any new setup macro. The VNMR menus are stored in 
either /vnmr/menulib or ~/vnmrsys/menulib as simple text files. The VnmrJ files are in 
/vnmr/templates/VnmrJ/interface/MainMenu.xml or 
~/vnmrsys/templates/VnmrJ/interface/MainMenu.xml. These latter files call submenus. 
The relevant submenu should be changed to provide the additional experiment. All of 
these include statements that run the experiment setup macros. The syntax is obvious and 
one of the existing sections can just be copied and the name of the experiment changed.


#5 Edit a Set of Experiment-Specific Parameter Panels
A new experiment will often need new parameter entry "widgets" in the layout pages. As 
above, the easiest and fastest method is to use a shell and go to your user file 
~/vnmrsys/templates/layout. If this is not present, make the directory. Then copy a set of 
panels from a related or similar experiment from /vnmr/templates/layout if BioPack is 
installed in /vnmr, or from the local layout directory. Then rename this directory to the 
name of the new sequence. Now, the VnmrJ interface should reflect the related 
experiment. Use the parameter set already saved above. Either use your newly created 
setup macro, or recall the parameter set directly into the current experiment. The panels 
should look the same. Any new parameters, options, flags, etc should be added to the 
panel using the panel editor (Main Menu / Edit /  Parameter Pages).

Section 14.0 details the editing function that permits seeing the macros used. This editing  
function is also used to add new functions or new parameter entry boxes. When the 
panels are "saved" the relevant text files are stored in ~/vnmrsys/templates/dg (for 
VNMR) or ~/vnmrsys/templates/layout (for VnmrJ). They are stored under the pulse 
sequence name. When the collection of files is complete the directory may be copied to 
/vnmr/user_templates/dg (for VNMR) or /vnmr/templates/layout (for VnmrJ) for use by 
all users. 

These files should be created for maximum clarity and performance. The latter is 
accomplished by having the widgets run macros that use vnmr variables and Magical 
commands to make a task easy to do, but accurate and reliable. For example, one might 
have a button to set up an array, perform and acquisition and at the end perform 
processing that obtains a calibration value. Or, when a variable has a finite list of options, 
a radio button widget permits the variable to be set at one click, where the user sees the 
options with descriptive text alongside.

Again, it is not necessary to have these panels for a new sequence to run. The default 
panels will be used by the software, but the power of the interface will be severely 
compromised

#6 Create any Required Shapes
Any new shapes required by a pulse sequence must reside in either /vnmr/shapelib or 
~/vnmrsys/shapelib. These may be derived "on-the-fly" by Pbox statements within the 
pulse sequence code, or by the setup macro calling Pbox or a user-written program. As 
discussed above, the AutoUpdate (BPbiopack2) or AutoCalibrate macros run the macros 
BPsetupshapes and BPcal that produce any shapes needed by the pulse sequences 
provided. 

If your new sequence is constructed to use already-created BioPack shapes, no shapes are 
needed. However, the setup macro should set the parameter values such as shape name, 
shaped pulse width, shape power, etc. If special shapes are used they should be created 
and stored as .RF or .DEC files. Your setup macro or pulse sequence should set up the 
necessary parameter values for these shapes in your parameter set based on knowledge of 
the calibrations in the relevant channels. These are supplied by the BPrtppar macro and 
are therefore accessible to statements that follow within the setup macro.

Once these files have been written, they may be put directly into the active BioPack 
directories and they will operate just as any other experiment. If you desire to share your 
work with others please submit the files as a compressed tar file to Varian (see 
BioPack.README in BioPack.dir for contact information) and the new experiment will 
appear in the next update or release, along with an announcement in Varian NMR News.

16.0	  Pulse Sequence Design - Standard "C" code.

BioMolecular NMR experiments can be designed (through pulse sequences) in a variety 
of ways. The traditional approach is to design elements that have parameter control and 
to build the sequence by constructing a series of delays, power statements, pulses etc. that 
leave the operator to set specific values for all parameters. Thus, the user must calibrate 
the system to provide the "hard pulse" pw90's on all channels (this can be automated, as 
discussed above). However, sequence-specific elements such as region-selective pulses, 
water flipback pulses, decoupling and gradients would require the user to create text files 
for shapes and predict approximate power levels and pulse widths for the RF elements. 
This can be tedious and error-prone. A linear and predictable RF system, coupled with 
powerful pulse sequence and macro languages, permits the use of mathematics to 
calculate these values from the primary calibrations obtained by the user.

The underlying basis for the success of the BioNMR experiment is the predictability of 
spectrometer output. This means that calibrations of pulse widths at single power levels 
are sufficient for prediction of power levels for region-selective pulses. This is highly 
relevant for 13C in all of these experiments, but also for protons, where soft selective 
pulses are done on the water and spinlock periods are employed. 

The other factor allowing parameter prediction is that natural resonance frequencies for 
carbon and proton nuclei in proteins are observed to fall in specific regions with few but 
predictable exceptions. Each of these experiments is designed so that the 13C frequency 
is set at a specific 13C chemical shift (e.g. 56 ppm for alpha carbons in HNCA). The 
proton frequency is always placed at the water position and the 15N frequency in the 
center of the amide region. Hence, the frequency change to the C=O region is known at 
the existing magnetic field( e.g. (174-56)*dfrq in Hz).

 Since all of these sequences involve region-selective 90's and 180's on the carbonyl, 
alpha, or alpha/beta carbon regions, the lengths of the pulses can be easily and 
automatically calculated so as to provide the required excitation nulls (e.g. at 600 Mhz a 
55 usec 90 degree pulse centered at 56 ppm has its first excitation null at 174 ppm). The 
BPcal macro, for example, uses the spectrometer frequency "sfrq" to automatically create 
all shapes needed by many pulse sequences. Similarly, the BPsetupshapes macro can 
calculate decoupling waveforms for many types of band-selective 13C decoupling. In 
principle, the *.RF files need only be created once since the magnetic field and offset 
positions (in ppm) are not changed. This forms the basis for the first implementation of 
BioMolecular NMR sequences currently used (as developed by Robin Bendall).

The power levels necessary for these pulses do need to be determined so that the proper 
flip angles are generated. This operation is done as a part of "go" within the pulse 
sequence, based on the tpwr, pwClvl, pwNlvl and amplifier compression values. The 13C 
and 15N coarse attenuators are not changed and all power levels can be adjusted via the 
linear modulators present on each channel, or Pbox can be called within the pulse 
program to generate the shapes (based on the same calibrations) and obtain the 
parameters for power and pulse timing (see below). Thus, as long as the "hardpulse" 
pulse widths are calibrated, nothing else is required.  The flexibility necessary to do this 
is, of course, a property of the "c" or SpinCAD language used in the pulse program. 
These principles are illustrated below in Table 18 for the HNCO experiment (ghn_co.c).

       Table 18  Excerpts from the ghn_co.c Pulse Sequence Code   

The first part of most sequence codes is a comment section:

    /*  ghn_co.c

    Correlates CO(i) with N(i+1), NH(i+1).  Uses constant time evolution
    for the 15N shifts.

    Standard features include maintaining the 13C carrier in the CO region
    throughout using off-res SLP pulses; square pulses on Ca with first
    null at 13CO; one lobe sinc pulses on 13CO with first null at Ca; one lobe
    sinc pulse to put H2O back along z (the sinc one-lobe is significantly more
    selective than gaussian, square, or seduce 90 pulses); preservation of H20
    along z during t1 and t2; waltz H1 decoupling during N15 evolution to
    decrease S/N loss via H1 exchange with H2O.  

    Magic-angle option for coherence transfer gradients.  TROSY option for
    N15/H1 evolution/detection. */


Later in the code, parameter values are obtained to be used in expressions. New variables 
are defined if needed (no getval). (All 13C power levels are set using the fine power 
(linear modulator) settings which can be set between 0 and 4095. The channel 2 
attenuator used for 13C is left constant at pwClvl):
.
.
.      (statements omitted)
.
.

/* the following pulse lengths for shaped pulses are automatically calculated */
/* by the experiment setup macro (ghn_co). Pulse shapes, "offC3" etc, were    */           
/* already created by the macro "BPcal". They are stored in your shapelib or  */ 
/* the system shapelib. The getvals obtain values from the your parameter set  */   
               
   pwC3 = getval("pwC3"),  /*180 degree pulse at Ca(56ppm) null at CO(174ppm) */
   pwC6 = getval("pwC6"),     /* 90 degree selective sinc pulse on CO(174ppm) */
   pwC8 = getval("pwC8"),    /* 180 degree selective sinc pulse on CO(174ppm) */
   rf3,	                           /* fine power for the pwC3 ("offC3") pulse */
   rf6,	                           /* fine power for the pwC6 ("offC6") pulse */
   rf8,	                           /* fine power for the pwC8 ("offC8") pulse */

   pwHs = getval("pwHs"),	          /* H1 90 degree pulse length at tpwrs */
   tpwrsf = getval("tpwrsf"),           /* fine power for pwHs pulse          */
   tpwrs,	  	               /* power for the pwHs ("H2Osinc") pulse */
 
   pwHd,	    		         /* H1 90 degree pulse length at tpwrd */
   tpwrd,                      /* attenuator setting for 1H WALTZ decoupling */
.
.
.

In this section, expressions are used (from theory) to calculate the fine power settings for 
the linear modulator on channel 2 for the band-selective 13C pulses:
.
.
.
/* Calculate fine power for 180 degree pulse on Ca, null at CO 118ppm away */
   rf3 = 4095.0*(compC*pwC*2.0/pwC3);
   rf3 = (int) (rf3 + 0.5);

 /* Same for 90 degree one-lobe sinc pulse on CO, null at Ca 118ppm away */
   rf6 = 4095.0*(compC*pwC*1.69/pwC6);	 /* needs 1.69 times more     */
   rf6 = (int) (rf6 + 0.5);		        /* power than a square pulse */

 /* Same for 180 degree one-lobe sinc pulse on CO, null at Ca 118ppm away */
   rf8 = 4095.0*(compC*pwC*2.0*1.65/pwC8);	 /* needs 1.65 times more     */
   rf8 = (int) (rf8 + 0.5);		        /* power than a square pulse */
.
.
.
The rf3 value is calculated using the value of the selective pulse pwC3 and the hard-pulse 
180-degree pulse calibration of (compC*pwC*2.0) (compC corrects pwC to the 
uncompressed value). The expression can be understood as a scaling down of 4095 by a 
factor of the ratio of the hard-pulse 180-degree pulse length to the region-selective 180-
degree pulse length. In the trivial case of pwC3 being twice as long as compC*pwC*2.0, 
the ratio is 0.5 and the resulting fine power is just 2048, as expected.
The rf6 and rf8 cases are for "sinc" pulses. The fine powers have to be multiplied by a 
theoretical factor to compensate for the calibration being done with a rectangular pulse, 
whereas the region-selective pulses are to be done by a shaped pulse. Otherwise, the same 
considerations apply as for rf3.

Aside from non-selective 1H pulses done using tpwr and pw, 1H decoupling and 
selective H2O flipback pulses are needed. The power level for these pulses is controlled 
by the attenuator only. Again, the expressions use a ratio involving a high power pulse 
width and a pulse width at lower power:
.
.
.
/* selective H20 one-lobe sinc pulse done at power level tpwrs and pulse width pwHs*/
    tpwrs = tpwr - 20.0*log10(pwHs/(compH*pw*1.69));  /* sinc needs 1.69 times more */
    tpwrs = (int) (tpwrs+0.5);                        /* power than a square pulse */

/* power level and pulse time for WALTZ 1H decoupling at field strength waltzB1(Hz)*/
	pwHd = 1/(4.0 * waltzB1) ;         
	tpwrd = tpwr - 20.0*log10(pwHd/(compH*pw));
	tpwrd = (int) (tpwrd + 0.5);
.
.
.
.
After all the calculations the actual pulse sequence is ready to begin. The next section 
shows how the calculated values are used for the region selective pulses offC6 and offC8, 
as well as the water flipback pulse(the fine power parameter tpwrsf allows adjustment of 
the power to account for radiation damping):
.
.
.

       	decpwrf(rf8);                                         /* set fine power */
	decshaped_pulse("offC8", pwC8, zero, 0.0, 0.0);
 	decpwrf(4095.0);                  /* reset fine power to maximum value  */
.
.
.
	decpwrf(rf6);
	decshaped_pulse("offC6", pwC6, t5, 0.0, 0.0);
	decpwrf(4095.0);
.
.
.
        obspower(tpwrs);             /* set attenuator for H2O selective pulse */
         if (tpwrsf<4095.0)
	   obspwrf(tpwrsf);            /* permits fine adjustment of soft pulse */
   	 shaped_pulse("H2Osinc", pwHs, three, 0.0, 0.0);
        obspower(tpwr);                   /* reset attenuator to normal power  */
.
.
.
}		 


17.0 "C" Pulse Sequence Design using Pbox.

Two alternative methods of using phase-ramped pulses are included. These methods call 
Pbox for shape creation at the time of "dps" and "go". No shapes are required in shapelib 
for this method. These sequences have a "P" (BioNMR) or "A" (AutoCalibrated or Pbox-
based) appended to the normal names. (SpinCAD sequences may incorporate Pbox via 
the use of  "AutoShaped Pulse", see below) 

BioNMR ("P") Versions:

 The "*P.c" sequences must be compiled the "bionmr.h" include file, while the "*A.c" 
sequences requires the "Pbox_bio.h" include file.

The "*P.c", or BioNMR, versions use non-standard psg elements that are written with 
protein 13C bandwidths pre-defined so that terms such as "ca", "co" and "cacb" are used. 
The operation, parameters and performance of these are at least as good as the original 
sequences. The only differences are that the phi7cal value may be different, and that the 
"dof" value is always set to the carbonyl carbon frequency for all experiments. The virtue 
of this approach is that new sequences can still be written in "C", but using high-level 
elements that do not require mathematical expressions (as above) to calculate power 
levels or pulse widths, and that no shapes need be prepared ahead of time. P sequence 
codes are typically half the length of the original versions.

BioNMR parameter sets are accessible either by directly entering the macro, e.g.
ghn_co_caP, by using the VNMR menu buttons:  Setup....Proteins...BioNMR Expts
followed by choosing the desired button, or in VnmrJ by selecting the BioNMR Version 
button in the Pulse Sequence page in the Acquire folder after selecting the generic 
experiment from the drop-down menu.

Remember: the dof value for all *P.c pulse sequences should be set for the carbonyl 
region. The BPbiopack2 macro does update the probefile for this offset, and experiment 
setup macros for *P.c sequences set dof to this value.

The phi7cal value in either standard or BioNMR parameter sets is determined in the 
automatic calibration process, which updates the probefile. BioNMR experiments using 
phi7cal should use the phi7cal value determined in the AutoCalibrate in which BioNMR 
sequences are selected (via the menu in VNMR or in the Globals and Probfile page of the 
Setup Folder in VnmrJ). Table 19 shows how the same HNCO sequence elements 
described above in Table 18 are modified for ghn_coP.c.


       Table 19  Excerpts from the ghn_coP.c Pulse Sequence Code   

The first part of most sequence codes is a comment section:

/*  ghn_coP.c

    3D HNCO gradient sensitivity enhanced version using Pbox to generate shapes.
.
.
.
    The N15 t2 evolution and the sensitivity enhancement train is common
    to all ghn_... sequences and the pulse sequence code for these final
    sections is in the include file, bionmr.h.
*/
.
.
.
.
The bionmr.h include file must be added

#include <standard.h>
#include "bionmr.h"
.
.
.
  

   pwHs = 1.7e-3*500.0/sfrq;            /* length of H2O flipback, 1.7ms at 500 MHz*/
   widthHd=2.681*(waltzB1/sfrq);           /* 2.681 factor produces same bandwidth */
                                           /* as ghn_co.c sequence  */
   pwHd = h1dec90pw("WALTZ16", widthHd, 0.0);     /* H1 90 length for WALTZ16 */

    /* get calculated pulse lengths of shaped C13 pulses */
	pwS1 = c13pulsepw("co", "ca", "sinc", 90.0); 
	pwS2 = c13pulsepw("ca", "co", "square", 180.0); 
.
.
.
The BioNMR "h1dec90pw" function returns the pulse width for a 90 degree pulse at the 
power level needed to produce the decoupling field widthHd (in Hz). The BioNMR 
function "c13pulsepw" returns the pulse width corresponding to the specified shape, 
region and flip-angle. The first two arguments specify the position at which the excitation 
occurs and the first null in the excitation. Note that these two arguments are in "protein" 
language and specify the alpha and carbonyl regions of the 13C spectrum. The pulse 
widths are not obtained from the parameter table, so a function is needed to obtain the 
values which are needed in subsequent expressions in the pulse sequence code.

Later, at the start of the pulse sequence, the BioNMR statement "set_c13offset" is used to 
position the 13C transmitter. Again, note that the argument is not an offset, but a 
codeword. The only power statements needed are those for the high-power hard pulses. 
No 13C pulse widths are used, other than the hard-pulse value pwC.

.
.
.
    set_c13offset("co");
.
.
.
	
The H2O selective pulse power and pulse width are handled by the BioNMR function 
"shiftedpulse" which permits specification of shape, pulse width, flip-angle, and offset 
from tof. No power level is needed: 
.
.
.
    shiftedpulse("sinc", pwHs, 90.0, 0.0, two, 2.0e-6, 0.0);
,
,
,
Proton decoupling is handled by the BioNMR function "h1waltzon" which specifies the 
decoupling pattern, field strength (in Hz) and offset from tof. No power values or pulse 
widths are needed: 
.
.
.
    h1waltzon("WALTZ16", widthHd, 0.0);
.
.
.

The 13C band-selective pulses power and pulse width are handled by the BioNMR 
function "c13pulse" which permits specification of shape, flip-angle, region to be excited 
and first null region. 

The sequence ends with the BioNMR function "hn_evol_se_train" which performs the 
last ~30% of the sequence including a band-selective 13C 180-degree pulse (and first 
null) during N15 evolution, t2 evolution, TROSY option, gradient coherence transfer, 
reverse INEPT and 15N decoupling during detection: 
.
.
. 

    c13pulse("co", "ca", "sinc", 180.0, zero, 2.0e-6, 0.0);
.
.
.
	
    c13pulse("co", "ca", "sinc", 90.0, t5, 2.0e-6, 0.0); 
.
.
.       
		
    hn_evol_se_train("co", "ca"); 
}



Summary of BioNMR psg elements:

Offset:
set_c13offset(fband)

C13 Pulses:
c13pulsepw(excband, nullband, c13shape, c13flip) 
c13pulse(excband, nullband, c13shape, c13flip, phase2, rofa, rofb) 
c13adiab_inv_pulse(excband, bandwidth, c13shape, pulsewidth, phase2, rofa, rofb)


Simultaneous 1H/13C Pulses:
sim_c13pulse(obsshape, excband, nullband, c13shape, obspw, c13flip ,phase1, phase2,
               rofa, rofb) 
sim_c13adiab_inv_pulse(obsshape, excband, bandwidth, c13shape, obspw, pulsewidth, 
                                         phase1, phase2, rofa,rofb) 

Simultaneous 1H/13C/15N Pulses:
sim3_c13pulse(obsshape, excband, nullband, c13shape, dec2shape,  
               obspw, c13flip, dec2pw, phase1, phase2, phase3, rofa, rofb) 
sim3_c13adiab_inv_pulse(obsshape, excband, bandwidth, c13shape, dec2shape,  
               obspw, pulsewidth, dec2pw, phase1, phase2, phase3, rofa, rofb)

Frequency-Shifted 1H Shaped Pulse:
shiftedpulse(anyshape, pwbw, flip, shift, phase1, rofa, rofb) 

Frequency-Shifted 13C Shaped Pulse:
decshiftedpulse(anyshape, pwbw, flip, shift, phase2, rofa, rofb) 

Frequency-Shifted 15N Shaped Pulse:
dec2shiftedpulse(anyshape, pwbw, flip, shift, phase3, rofa, rofb) 

Frequency-Shifted 1H/13C/15N Simultaneous Centered Shaped Pulses:
sim3shiftedpulse(obsshape, anyshape, dec2shape, obspw, pwbw, flip, shift, 
                                dec2pw, phase1, phase2, phase3, rofa, rofb) 

13C Decoupling:
c13decon(decband, c13shape, decbandwidth)
c13decoff()
c13decouple(decband, c13shape, decbandwidth, duration)

1H Decoupling:
h1decon(h1shape, decbandwidth, shift)
h1decoff()
h1decouple(h1shape, decbandwidth, shift, duration)
h1waltzon(h1shape, decbandwidth, shift)
h1waltzoff(h1shape, decbandwidth, shift)

N15 t2 Evolution with 13C Refocussing and Sensitivity-Enhancement
nh_evol_se_train(excband, nullband)

Identify Desired Decoupling Waveform for Pbox
installdecshape(decshape)




Shape File Parameter Extraction Tools
              (to obtain parameters from Pbox-generatedshapes)
c13shapefiles(excband, nullband, c13shape, c13flip);
fshapefiles(anyshape, pwbw, flip, shift)
c13adiab_files(excband, bandwidth, c13shape, pulsewidth)
c13decfiles(decband, c13shape, decbandwidth)
h1decfiles(h1shape, decbandwidth, shift)

Automatic Pbox-Based Designs (the "AutoCal" approach):

The "A" versions include a header section in the pulse sequence where all shapes are 
created and the parameter values from these shapes are obtained at "go" time. This mode 
of operation allows the conversion of existing pulse sequences of any style to "A" 
versions without modification of the underlying codes (developed by Eriks Kupce, 
Varian). The difference between an "A"-sequence and the corresponding "BioNMR, or 
P-" sequence is that the later introduces a completely new syntax for executing shaped 
pulses, whereas the "A" sequence requires minimal interference with the existing pulse 
sequence code. Therefore, the syntax that is used in the "A" sequences provides a quick 
and easy way to convert long and extensive pulse programs into spectrometer-frequency 
independent, fully automatic experiments using the same parameter names and 
calibrations as standard experiments. The ultimate goal is to reduce the portability issues 
of complex multi-dimensional bio-NMR experiments. Table 20 shows the steps 
necessary to convert a "standard" (ghn_co.c) pulse sequence. 

       Table 20  Excerpts from the ghn_coA.c Pulse Sequence Code   

/*  ghn_coA.c

    3D HNCO gradient sensitivity enhanced version using Pbox to generate shapes.
    AutoCal version with optional offset checking.
.
.
.

*/
.
.
  (existing ghn_co.c code statements)
.
.
.

This next part is added after the #include <standard.h> statement:
   
#include "Pbox_bio.h"                             /* include new AutoCalfunctions */
static double   H1ofs=4.7, C13ofs=174.0, N15ofs=120.0, H2ofs=3.2; 
static shape H2Osinc, wz16, offC3, offC6, offC8;
.
.   (existing ghn_co.c code statements)
.
  double bw, ofs, ppm, ...      /* bandwidth, offset, ppm  are only new parameters*/
.
    (existing ghn_co.c code statements)
.
.
If autocal='n' the pwC3, pwC6 and pwC8 values will be obtained from the parameter set 
in the normal manner using the getval statements already used in the statements above 
and the rf3, rf6 and rf8 values will be calculated in the above section as before.

 If autocal='y' the next section will calculate the needed shapes based on pwC, pwClvl  
and compC (using pbox_make) and then set the appropriate pulse widths pwC3, pwC6  
and pwC8 to be used by the shaped pulse statements within the main body of the code. 
The fine powers rf3, rf6 and rf8 are also obtained from the header of the shape in the 
relevant shapelib. The shapes are created at "go" and are only done for the first 
increment.

Note that the arguments of "pbox_make" are the name of the new shape, the type of 
shape, the bandwidth of the pulse (in Hz), the offset from the 13C transmitter at which 
the excitation occurs and the calibration pulse width and power. 

The proton decoupling waveform and the H2O selective shape are created based on the 
calibrations compH*pw and tpwr. The relevant pwHs, tpwrd and pwHd parameters are 
obtained from the shapefile header.

 The optional offset check (ofs_check) produces a warning message if the specified actual 
offsets are in significant deviation from the actual defined shifts in ppm. This is done by 
an absolute chemical shift calculation. 

  setautocal();                                  /* activate auto-calibration flags */ 
  if (autocal[0] <> 'n')                               /* specifies automatic setup */ 
  {
    if(FIRST_FID)                       /* calculate all shapes and do it only once */
    {
      ppm = getval("dfrq");                 /* have Pbox use 13C frequencies, not 1H*/
      bw = 118.0*ppm; ofs = -bw;                            /* calculate bw and ofs */

      offC3 = pbox_make("offC3", "square180n", bw, ofs, compC*pwC, pwClvl);
      offC6 = pbox_make("offC6", "sinc90n",    bw, 0.0, compC*pwC, pwClvl);
      offC8 = pbox_make("offC8", "sinc180n",   bw, 0.0, compC*pwC, pwClvl);

      H2Osinc = pbox_Rsh("H2Osinc","sinc90", pwHs, 0.0, compH*pw,  tpwr);
      bw = 2.8*waltzB1;
      wz16 = pbox_Dcal("WALTZ16", bw, 0.0, compH*pw, tpwr);
 
      ofs_check(H1ofs, C13ofs, N15ofs, H2ofs);                 /* check all offsets */
    }
      pwC3a = offC3.pw; rf3 = offC3.pw       /* get parameter values from shape file*/
      pwC6 = offC6.pw; rf6 = offC6.pwrf; 
      pwC8 = offC8.pw; rf8 = offC8.pwrf;
      pwHs = H2Osinc.pw; tpwrs = H2Osinc.pwr-1.0;         /* 1dB correction applied */
      tpwrd = wz16.pwr; pwHd = 1.0/wz16.dmf;
  }

The rest of pulse sequence follows as originally written. This is the virtue of the AutoCal 
approach. Any *.c code may be converted to an automatic version by inserting a similar 
section near the top of the existing code.



Automatic Pbox-based Pulse Sequence Definitions

setautocal() - Sets up the autocal and checkofs flags. 
Syntax:  (void) setautocal();

Description: Creates the autocal and checkofs flags and checks if they are set in the 
current experiment. If the flags are not set, they are defaulted to 'y' (yes). The available 
options for the checkofs flag are: 'y' and 'n' . For the autocal flag the available options are: 
'y' , 'q' (quiet mode - suppress Pbox output), 'r' (read from file, no new shapes are 
created), 's' (semi- automatic mode - allows access to user defined parameters) and 'n' .

ofs_check() - Checks carrier frequencies on all 4 channels.
Syntax: (void) ofs_check(H1ofs, C13ofs, N15ofs, H2ofs); 
             double H1ofs, C13ofs, N15ofs, H2ofs;

Description: The ofs_check() function checks the settings of tof, dof,  dof2 and dof3 of 
four RF channels against the values (in ppm) provided as arguments. The allowed 
deviations are set internally to 0.2 ppm for H-1 and H-2 and to 2.0 ppm for C-13 and N-
15. It is assumed that channel 1 is H1, channel 2 is C-13, channel 3 is N-15 and channel 4 
is H-2. The offset (tof, dof, dof2 and dof3) checks can be switched off individually by 
setting the corresponding argument to zero (0.0), or collectively by checkofs = 'n'; 

pbox_make() - Create and calibrate a shaped pulse.
Syntax: 
  shape   shp;
  char    shn[MAXSTR], wvn[MAXSTR];
  double  bw, ofs, ref_pw90, ref_pwr;
  shp = pbox_make(shn, wvn, bw, ofs, ref_pw90, ref_pwr);

Description: 
shp -          pre-defined shape structure containing all the experimental parameters that are
                  required in order to execute a shaped pulse or a decoupling waveform. 
                  shp must be declared as a shape.
shn -          output shape name as used in the pulse sequence;
wvn -         waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz); alternatively pulse duration in seconds can
                  be used;
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The pbox_make() function returns a shape structure (as defined in Pbox_psg.h) that 
contains all parameters required by the experiment.. For frequency-shifted pulses the 
maximum phase increment is internally restricted to 10 degrees, which guarantees a 
proper RF performance. The shapes are calibrated to use a fixed coarse attenuator setting 
that is set at ref_pwr level and a variable fine attenuator setting.

pbox_makeA() - Create and calibrate an adiabatic pulse. 
Syntax:
  shape    shp; 
  char      shn[MAXSTR], wvn[MAXSTR];
  double  bw, pws, ofs, ref_pw90, ref_pwr, nst;
  shp =    pbox_makeA(shn, wvn, bw, pws, ofs, ref_pw90, ref_pwr, nst);

Description:    
shp -           pre-defined shape structure containing all the parameters required in order
                   to execute a shaped pulse or a decoupling waveform. 
                   shp must be declared as a shape.
shn -           output shape name as used in the pulse sequence;
wvn -         waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz);
pws -          pulse duration (in seconds);
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -  reference power level, e.g. pwClvl;
nst -           number of steps

The same as pbox_make(), except simultaneous definition of bandwidth (bw) and pulse 
duration (pws) is allowed. This function is used to create and calibrate adiabatic pulses 
and waveforms. The nst parameter defines the number of steps in the shapefile. If nst is 
set to zero, the required number of steps is calculated by Pbox. 

pbox_makeR() - Create and calibrate a shaped pulse
Syntax: 
   shape    shp;
   char      shn[MAXSTR], wvn[MAXSTR];
   double  bw, ofs, ref_pw90, ref_pwr;
   shp  =   pbox_makeR(shn, wvn, bw, ofs, ref_pw90, ref_pwr);

Description:    
shn -          output shape name as used in the pulse sequence;
wvn -        waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz); alternatively, pulse duration in 
                  seconds can also be used;
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The same as pbox_make(), except the status parameter is set to 1. The result is a time-
reversed (de-excitation) pulse.

pbox_Rsh() - Create and calibrate a shaped pulse using coarse power
Syntax:
   shape    shp;
   char      shn[MAXSTR], wvn[MAXSTR];
   double  bw, ofs, ref_pw90, ref_pwr;
   shp =    pbox_Rsh(shn, wvn, bw, ofs, ref_pw90, ref_pwr)   

Description: 
shn -           output shape name as used in the pulse sequence;
wvn -         waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz); alternatively pulse duration in 
                  seconds can also be used;
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The same as pbox_make(), except the shapes are calibrated to use the coarse attenuator 
setting. The fine attenuator setting remains at 4095.0 and internal fine attenuation is used 
instead.

pbox_Dsh() - Create and calibrate a .DEC waveform using coarse power
Syntax:
   shape    shp;
   char      shn[MAXSTR], wvn[MAXSTR];
   double  bw, ofs, ref_pw90, ref_pwr;
   shp =    pbox_Dsh(shn, wvn, bw, ofs, ref_pw90, ref_pwr);

Description: 
shn -           output shape name as used in the pulse sequence;
wvn -         waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz); alternatively pulse duration in 
                  seconds can also be used;
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The same as pbox_Rsh(), except .DEC type shape file is produced in the
output.



pbox_Dec() - Create and calibrate a .DEC waveform for a given coarse 
                        power setting.
Syntax:
   shape    shp;
   char      shn[MAXSTR], wvn[MAXSTR];
   double  bw, decpwr, ref_pw90, ref_pwr;
   shp  =   pbox_Dec(shn, wvn, bw, decpwr, ref_pw90, ref_pwr);

Description: 
shn -           output shape name as used in the pulse sequence;
wvn -         waveform name as in /vnmr/wavelib;
bw -           excitation bandwidth (in Hz); alternatively pulse duration in 
                  seconds can also be used;
ofs -           excitation offset (in Hz) from the carrier frequency; 
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The pbox_Dec() function is used to create decoupling and mixing waveforms. If a 
positive decpwr value is supplied, the dmf and dres parameters are calibrated as for the 
given decpwr; alternatively the required decoupling bandwidth can be used to calculate 
dpwr, dmf and dres. Note that in mixing experiments the effective mixing bandwidth is 
usually 2*B1(max) or less. This should be used to set up the bw parameter. The fine 
attenuator should be set to 4095.0;

pbox_Dcal() - decoupling calibration routine
Syntax:
   shape    shp;
   char      wvn[MAXSTR];                         /* parameter names */
   double  bw, decpwr, ref_pw90, ref_pwr;
   shp  =   pbox_Dcal(wvn, bw, decpwr, ref_pw90, ref_pwr);

Description: 
wvn -         waveform name as in /vnmr/wavelib;
bw -            required decoupling bandwidth (in Hz), if 0.0 then not used;
decpwr -     required decoupler power, if 0.0 then not used;
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The same as pbox_Dsh(), except no shapefile is created in the output. The experimental 
parameter set is returned in the form of the shape structure, that contains shape.pwr 
(coarse power), shape.pwrf (fine power, set to 4095), shape.dres (dres parameter) and 
shape.dmf (dmf parameter); 

pbox_Rcal() - selective pulse calibration routine
Syntax:
   shape    shp;
   char      wvn[MAXSTR];                         /* parameter names */
   double  bw, ref_pw90, ref_pwr;
   shp  =    pbox_Rcal(wvn, bw, ref_pw90, ref_pwr);

Description: 
wvn -        waveform name as in /vnmr/wavelib;
bw -           required decoupling bandwidth; alternatively pulse duration in 
                  seconds can also be used;
ref_pw90 - reference pulse length, e.g. compC*pwC;
ref_pwr  -   reference power level, e.g. pwClvl;

The same as pbox_Dcal() except the shapes are calibrated to use a fixed coarse attenuator 
setting set at ref_pwr level and a variable fine attenuator setting, as used in bio-pack 
sequences. The returned shape structure contains parameters required for .RF shape 
format: shape.pwr (coarse power), shape.pwrf (fine power), shape.pw (pulseduration). No 
shapefile is produced in the output.

18.0 Pulse Sequence Design using SpinCAD.
      
SpinCAD is a graphical "drag-and-drop" pulse programming language. It is activated by 
the "spincad" command in VNMR or by using the Edit drop-down menu in VnmrJ. 
BioMolecular pulse sequences can be programmed in SpinCAD and the software 
includes many examples, including HNCO (ghn_coSP). It has full functionality and the 
sequences produce data equal in quality to the above methods. Macros and parameter sets 
are included for these sequences. Experiments can be set up via the menu bar in VNMR 
or by appropriate buttons in the Pulse Sequence panel of the VnmrJ layouts.

19.0  3D Projection Reconstruction Experiments.

Introduction
      
A number of BioPack pulse sequences have been coded to permit "linked" acquisition of 
indirect dimensions to permit rapid 3D experiments. These have a "pra" parameter (use 
the Experiments drop-down menu and select "Protein Triple-Resonance"..."Projection 
Reconstruction (TILT)" to view these experiments). If the value of "pra" is zero or 90 
degrees, a normal F1F3 or F2F3 2D experiment will be performed under the control of
ni/sw1 or ni2/sw2. 

 If "pra" is between 0 and 90 degrees, the t1 and t2 evolution times are co-incremented 
under the control of ni and sw1. Under favorable circumstances it is possible that the 
chemical shifts characterized by F1, F2 and F3 for each residue may be determined from 
as few as one projection (or "tilted") 2D plane along with the orthogonal F1F3 and F2F3 
2D planes. More typically it may require several tilted planes.

Any of the above mentioned experiments may be run just by setting "pra". However, the 
best projection angles needed are not known in advance. Several different 2D 
experiments using different "pra" values could be set up and run manually, but this may 
result in more time used than optimal or necessary. For this reason, BioPack has an 
interface to manage the optimal collection of PR experiments.

This management is done via the "Proj.Reconstr." page in the "Acquire" folder in the 
VnmrJ interface. This page will be visible for any sequence using the "pra" variable.

The variables visible in this interface are all "global" parameters, not those in the current 
parameter set. The current experiment's parameters will be overwritten when the PR 
queue begins. However, if the current parameter set has a first increment ghn_co data set 
the spectrum can be referenced, phased and expanded to show only the NH's. The values 
of sp/wp and rp/lp will be set into global variables by the button at the lower left of the 
panel. This is an important step because only signals within this window will be 
analyzed, and no autophasing is done for any PR data. Rather, the phase settings for the 
ghn_co data set will be used, via the stored global variables.

The purpose of the panel is to specify the total number of pulse sequences to be used 
(only those using the "pra" variable), the names of these sequences and the values 
controlling the 2D acquisitions (ni/ni2/sw/sw1/sw2/niTilt/nt). After specifying the names 
of the experiments, the "Initialize" button runs a macro that sequentially runs the setup 
macros for each of the specified pulse sequences (although not a PR experiment, gNhsqc 
may be used as the first experiment to acquire a high S/N and complete NH 2D 
experiment. If the "skip F2F3" option is used, this data set serves for obtaining the NH 
2D chemical shifts). After each setup macro is run, the values of sw, sw1 and sw2 are set 
into the PR global variables visible in the panel. Because these are "global" they are not 
overwritten by recalling a parameter set. 

The user is now free to modify the parameter values as desired. See below for details on 
the choices available. The number of transients should be set relative to the intrinsic 
sensitivity of the sequence specified. A larger number than normal for ni and ni2 may be 
used for better resolution since these are 2D acquisitions for the orthogonal planes and 
each orthogonal plane is only acquired once, as opposed to the possibly several tilted 
planes. 

Analysis will be most reliable if there is a reasonable estimate of the number of peaks to 
be expected for each experiment. This is a function of the sequence and number of amino 
acids in the protein. To be safe, specify a somewhat larger number than necessary, but not
smaller than the number of expected peaks.

The Threshold parameter is used to prevent analysis of "noise" or "artifact" peaks. Since 
most backbone assignment data have peaks with a limited range of intensities, there is 
little loss of information by setting the threshold to 0.2-0.4. If S/N is high, the threshold 
can be lower.

If all peaks for a given experiment should be positive, the "Positive Only" checkbox can
be selected. This will make the analysis more robust.

The "Show Time" button is used to show the minimum and maximum time needed for 
the requested experiments. Recall that at least one (F1F3) orthogonal plane is acquired, 
along with one or more experiments where "pra" is between 0 and 90 degrees. If the 
Automatic Angle option is used, the data is analyzed after the last orthogonal plane 
acquisition and after each tilted plane acquisition to obtain the most informative value of 
"pra" for the next tilted plane acquisition. This results in the most efficient use of time.
Once the values of ni/ni2/nt are re-adjusted to fit the total available time, the "Begin" 
button is used to start the queued experiments.

All acquisitions occur in the "current experiment". Data are stored in the specified 
storage directory under subfiles named for the different pulse sequences used. 
Acquisition is controlled by the normal "wexp" variable. Experiments may be interrupted 
by aborting acquisition in the normal manner, but the current 2D data is then lost. When 
the process is desired to resume, the normal "au" command will restart the acquisition 
with those parameters in the "current experiment". For this reason, no local variables 
should be changed before restarting.

Note that there is a "Manual (See Text Output)" button. This produces a set of 
instructions for setting up a PR  queue. The manual lists and defines all the global PR 
variables. After using this button, select the "Text Output" page.

How to Run a PR Series 

Once a sample is ready for acquisition, a 1D ghn_co spectrum should be obtained with 
good S/N, adequate to show all NH's. The spectrum should be phased, referenced and 
then expanded to show the NH region only. The phase settings and display settings will 
be used for analysis of data from the PR experiments.
Enter the number of PR experiments desired in the top entry box and then their names in 
the "experiment" column, scrolling if more than 3 sequences are to be used. Make sure 
that the sequences entered (except for gNhsqc) have the Projection Reconstruction option 
(they have a "pra" parameter that is active). Do not enter any other parameters at this 
time. 
Click the "NH Region Phased and Expanded" button to memorize the phasing and 
display parameters into global variables. Click the "Initialize" button to populate the 
parameter settings. Modify any of these values as desired at this time, including the 
relaxation delay used for all experiments, whether to collect F2F3 planes for each as 
opposed to using data from gNhsqc or ghn_co (if the first experiment in the list) and 
whether to have the software automatically select the NH region of the first experiment 
for further analysis.
 The spectral widths in F1 and F2 for 13C and 15N should be matched to the actual 
spread of frequencies for these nuclei in order to have the highest possible resolution for 
the chosen ni, ni2 and niTilt. This will permit the most accurate analysis of peak positions 
(see below for more details on the choices of sw1 and sw2). Enter desired options for 
Auto Angle Select, Peak Threshold, Number of Peaks and Positive Peaks. Depending on 
the total time available, set the Maximum Number of Angles.
Enter the full pathname of the storage directory and the name of the directory used for 
this series. Click the "Show Time" button to obtain an estimate of the total time. This step 
also checks for too many increments in constant time experiments and will display output 
in the text window if the maximum number of increments is exceeded for any of the 
experiments, assuming that the pulse sequence code has been written to show these 
messages. (Note, if the Spectrometer Message button on the hardware toolbar turns red, it 
is likely that this has happened.) 
If this time is acceptable, click "Begin", otherwise adjust parameters to meet the 
requirements. The data will be stored in the specified storage directory. This directory 
will have subdirectories named for the sequences used. These subdirectories will have the 
stored fids and analysis output in the form of text files. While the experiments are 
running, histograms are displayed showing the optimum angle used for the next 
experiment for the best chance of resolving overlapped peaks.
It is possible to reset the PR variables for experiments still not run while acquisition is 
proceeding. However, the output file PRglobals stored in the output directory will not 
reflect these changes. 
Setting the optimum sw1 in tilted experiments

The optimum setting for sw1 in tilted experiments is determined from the peak positions 
in the orthogonal planes. For instance, in HNCO spectra of ubiquitin the CO signals are 
found in the range between 170.50 and 180.75 ppm. On a 600 MHz instrument this 
corresponds to a bandwidth of 1537.5 Hz. Likewise the N-15 chemical shifts range from 
102.42 to 132.94 ppm which corresponds to a bandwidth of 1831.2 Hz. Hence the 
maximum theoretically possible span of signals in tilted experiments is :
sqrt(1537.5*1537.5 + 1831.2*1831.2) = 2391.07 Hz
In practice the real bandwidth depends on the sample and is always smaller than the 
theoretically calculated value because we rarely (if ever) find cross-peaks in the corners 
of the 3D space. Therefore, the largest setting for the spectral width in the indirect 
dimension in this particular case is sw1 = 2400 Hz. 
In order to accommodate the displaced axial peaks (particularly the water signal) the sw1 
setting needs to be somewhat wider than the chemical shift range. Hence practical 
settings for sw1 (CO) and sw2 (N15) are ~ 2000 Hz and 2200 Hz. 
There are two options for setting sw1 for the tilted planes. Setting the global variable 
PRvarsw1 (variable sw1 flag) to 'n' (the "Auto sw1" checkbox) will always use 
displayed sw1 value (PRsw1), which in the case of HNCO should be set to 2400 Hz (at 
600 MHz). If the "Auto sw1" checkbox is set (PRvarsw1 is set to 'y') the sw1 is 
recalculated depending on the displayed sw1, sw2 and  projection angle values (PRsw1, 
PRsw2 and pra). This, however, may cause problems in constant time experiments 
because the preliminary check (see above) is done for pra=0 only. However, increasing 
an indirect dimension spectral width for fixed # increments usually will not cause an 
error.

Global BioPack PR parameters common to all pulse sequences

PRsp, PRwp - determines the NH spectral range that is used for PR processing. These 
parameters are set by the "NH Region Phased & Expanded" button.
PRrp, PRlp - stores user-determined rp and lp values for PR processing. These would 
normally be determined by first running a first increment ghn_co, transforming, phasing 
and expanding to show the NH region containing peaks. Adequate S/N should be 
obtained for confident accounting of all NH's. PRsp and PRwp are derived from the 
resultant display. These parameters are set by clicking the "NH Region Phased & 
Expanded" button.
PRsetlim - y/n determines whether the display limits PRwp and PRsp are further 
optimized beyond on preliminary user defined values. This flag is only used once prior to 
the execution of the queue of PR experiments. It is set by the "Auto NH Region" 
checkbox.
PRskipF2 - allows the skipping acquisition of  the F2F3 (N-15) dimension. A value of 
'y' means that the F2F3 (NH) plane of the first experiment, e.g. N-15 HSQC or HNCO, is 
used for analysis (peak picking) to produce a peak list for use in experiments for 
subsequent pulse sequences. This peak list is copied into the experiment subdirectories 
for use by the automatic angle prediction. The flag is set by the "Skip 15N F2F3 Planes" 
checkbox.
PRd1 - relaxation delay used for all PR experiments. Its value is set in the 
"Proj.Reconstr." page.
PRnexp - number of PR pulse sequences to be used in the PR queue. Its value is set in 
the "Proj.Reconstr." page.

Global BioPack PR parameters specific to each pulse sequence

These global parameters contain settings for the corresponding variables in each of the 
pulse sequences used in the queue. They are arrayable parameters and they store the 
settings as arrays. For example, PR[5]npeaks would contain the value for the number of 
expected peaks for the fifth pulse sequence used. Their values are set in entry boxes, 
menus or in checkboxes in the "Proj.Reconstr." page.    
PRexp - pulse sequence name as stored in the active seqlib. This is entered in the 
"experiment" entry box.
PRnpeaks - approximate number of expected peaks in the spectrum. It is important to 
set this parameter to a reasonable number. If a large number of spurious (noise) peaks is 
picked up by the automatic routines, the calculation of the best projection angle may fail. 
This is selected via the "peaks" entry box. 
PRnpr - maximum number of tilted projections. Typically 2 to 3 for small proteins. The 
experiment may finish sooner if all PRnpeaks are found or if no new peaks are found. 
This is entered in the "Max # Proj." entry box
PRbpa - (y/r/n) determines whether to use optimized projection angles ('y') or to run the 
experiments with PRnpr regularly spaced ('r') tilt angles spanning 90 degrees. The third, 
option ('n') chooses the projection angles according to the sw1/sw2 ratio. 
PRpos - (y/n) determines whether to expect only positive peaks in the analysis. This 
helps to limit the number of spurious peaks in the peak lists and improves the prediction 
of the best projection angle. This is selected via the "Pos. Peaks" checkbox.
PRthr - the threshold (dynamic range) is used to reduce the number of spurious peaks in 
the peak lists and improves the prediction of the best projection angle. The expected 
values are between 0 and 1 with typical values ranging between 0 and 0.3. The PRthr 
value can be considered as the fraction of the average peak's height that is used to certify 
the acceptance of a peak as "real". The higher the value of PRthr, the fewer peaks that are 
found. For example, use 0.3 in N-15 HSQC of a small protein. This is entered in the 
"Thr." entry box.
PRvarsw1 - (y/n) variable sw1 flag. If set to 'y' the sw1 is recalculated for all tilted 
experiments from pra, PRsw1 and PRsw2 settings. Otherwise PRsw1 is used for all tilted 
experiments.
PRsw,  PRsw1,  PRsw2,  PRni, PRni2, PRnt, PRniTilt  These global parameters 
contain settings for the corresponding variables sw, sw1, sw2, ni, ni2 and nt in each of the 
pulse sequences used in the queue.  These are entered in the relevant entry boxes. The 
value of PRniTilt is entered in the "niTilt" entry box. Its value determines the number of 
increments in the tilted plane experiments.

Global BioPack PR parameters used internally
 
PRn - experiment counter; 
PRcnt - counter for tilted planes; 
PRppeaks - counter for resolved peaks;
PRdir - directory where data is stored. This is constructed from the "svfdir" VnmrJ 
variable along with the user-specified PR series name. This directory has subdirectories 
having the pulse sequence names. These contain the raw data files and analysis results.
PRpage - counter used in BioPack Projection Reconstruction page in the Acquire Folder. 

BP PR macros

BPglobalpar - Creates all global PR parameters. This macro is run only at the 
installation or update of BioPack. It should not be necessary for a user to run it.

BP_PRstartQ - macro, starts the experiment queue.
1)	Sets phase PRrp, PRlp and display variables PRsp and PRwp from the current 
settings of rp, lp, sp and wp;
2)	Resets the sequence counter PRn;
3)	Creates the working directory and stores the name  in PRdir;
4)	Initializes the first pulse sequence in the queue (PRnew macro );
5)	Creates the text file PRglobals in PRdir. This contains a record of the PR 
variables used for the experiment.
6)	Creates a text file PRmessages in PRdir. This accumulates messages also 
displayed in the message window during the experimental run.
7)	Starts the first experiment with au command.
8)	
BP_PRparams1 - macro, initializes global parameters.
1)	Saves the current parameter set;
2)	For each pulse sequence in turn - runs the experiment setup macro. Sets PR global 
parameters from current values into the global parameter arrays (PRsw, PRsw1, 
etc);
3)	Recalls the saved current parameter set into the current experiment;
4)	Deletes the saved current parameter set;


BP_PRQtime - macro, estimates total time.
1)	Saves the current parameter set;
2)	For each pulse sequence in turn - runs the experiment setup macro. Sets local 
parameters from values into the global parameter arrays (PRsw, PRsw1, etc);
3)	Runs go('check') on each sequence to verify max. # increments not exceeded. 
Messages are displayed in Text Output window.
4)	Calculates total time of each experiment and displays the result. Displays total 
time for all experiments.
5)	Recalls the saved current parameter set into the current experiment;
6)	Deletes the saved current parameter set;

BP_PRnew - macro; sets up a new pulse sequence
1)	Resets the PRcnt and PRppeaks counters; increments PRn counter;
2)	Creates directory according the pulse sequence name;
3)	Executes the pulse sequence macro;
4)	If PRskipF2 flag is active, copies F2 analysis data from the first sequence 
directory;
5)	Sets parameters for sw1, sw2, ni, ni2, niTilt, etc. from global parameters entered 
in Projection Reconstruction page in the Acquire folder ;
6)	Sets the wexp parameter;
7)	Calls BP_PRwc macro to adjust the display settings, wc and sc; 

BP_PR0 - macro, used exclusively for gNhsqc  data processing.
1)	Executes BP_Rproc1b processing macro;
2)	Saves data;
3)	Calls BP_PRnew macro to sets up the next pulse sequence in the queue;
4)	Starts the new experiment with au command.

BP_PR1 - macro, used for pre-processing of the F2F3 orthogonal plane data.
1)	Executes BP_PRproc1 processing macro;
2)	Saves data;
3)	Sets up acquisition parameters for the next (F1F3) plane;
4)	Starts the acquisition with au command.

BP_PR2 - macro, used for processing the F1F3 and F2F3  orthogonal plane data.
1)	Executes BP_PRproc1 processing macro to pre-process F1F3 plane data;
2)	Predicts (BP_PRgetbpa) and displays (BP_PRdbpa) the best projection angle 
from F1F3 and F2F3 analysis data;
3)	Sets up the tilted plane experiment (enters value for the angle "pra");
4)	Starts the acquisition with au command.

BP_PR3 - macro, used for processing tilted plane data.
1)	Increments the PRcnt counter;
2)	Saves data;
3)	Executes BP_PRproc1a processing macro to pre-process tilted plane data;
4)	Decides whether to continue the experiment; If not, calls the BP_PRnew macro to 
set up a new pulse sequence; Otherwise, predicts (BP_PRgetbpa) and displays the 
best projection angle from the processing of the last data set;
5)	Starts the acquisition with au command.

BP_PRproc1 - macro used for processing of the orthogonal plane data. 
1)	Executes 2D processing;
2)	If PRsetlim parameter is active, calls BP_PRgetlim macro to establish the spectral 
region of interest and sets PRsp and PRwp accordingly;
3)	Calls getpr1 binary executable for pre-processing of  orthogonal plane data.

BP_PRproc1a - macro used for processing of the tilted plane data. 
1)	executes 2D processing;
2)	Calls getpr1 binary executable for pre-processing of the tilted plane data.

BP_PRproc1b - macro used for processing of the N-15 HSQC data. 
1)	Executes 2D processing;
2)	If PRsetlim parameter is active, calls BP_PRgetlim macro to establish the spectral 
region of interest and sets PRsp and PRwp accordingly;
3)	Calls getpr1 binary executable for pre-processing of the orthogonal planes data.

BP_PRwc - macro, adjusts the sc and wc parameters

List of active BP PR macros
BPglobalpar, BP_PRparams1, BP_PRQtime, BP_PRstartQ, BP_PRnew, BP_PRglobals, 
BP_PR0, BP_PR1, BP_PR2, BP_PR3, BP_PRproc1, BP_PRproc1a, BP_PRproc1b, 
BP_PRwc, BP_PRgetlim, BP_PRgetnpks, BP_PRnpks, BP_PRgetbpa,  BP_PRvs2d.

Usage of BP PR macros
BP_PRstartQ    >> BP_PRnew, BP_PRglobals
BP_PRnew       >> BP_PRwc, BP_PR0 / BP_PR1 / BP_PR2
BP_PR0 (N15)  >> BP_PRproc1b, BP_PRnew
BP_PR1 (F2)    >> BP_PRproc1, BP_PR2 
BP_PR2           >> BP_PRproc1, BP_PRgetbpa, BP_PR3
BP_PR3           >> BP_PRproc1a, BP_PRnpks, BP_PRnew, BP_getbpa, BP_PR3 
BP_proc1       >> BP_PRgetlim, BP_PRgetnpks, BP_PRvs2d
BP_proc1a      >> BP_PRvs2d
BP_proc1b      >> BP_PRgetlim, BP_PRgetnpks, BP_PRvs2d

Pulse sequences
The following BioPack sequences have the option for Projection Reconstruction and have 
a 15N Semi-Constant-Time option - SCT = 'y':
ghn_co, ghn_coA, ghn_ca, ghn_caA, ghn_co_ca, ghn_co_caA, 
ghn_ca_co, ghn_ca_coA, gcbca_co_nh, gcbca_co_nhA, gcbca_nh, 
ghc_co_nh, ghc_co_nhA, ghn_cacb, ghn_cacbA.
This permits collection of much higher resolution data with more accurate peak picking 
and reduction of overlap.
Output files
A set of files is generated in the process of predicting the next best projection angle. 
These files are a by-product of the automation routine and are updated after each 
completed 2D plane. Hence, if the calculation needs to be repeated, the processing must 
be restarted from the beginning (F1 and F2). The final output file, PR.out contains some 
preliminary information about the peak positions found by the standard peak picking 
routine in the process of predicting the next best projection angle. 
Note that the standard peak picking routines often miss peaks that are closely 
overlapping. A more complete and accurate list can be generated following a full 
reconstruction of the nD spectra which, in general, requires fewer tilted experiments. 
Such reconstruction routines have been implemented in third party software (e.g. Olivia 
from Hokkaido University, PR-CALC, Duke University, and others.
The PR.out file contains the F3, F1 and F2 chemical shifts (in ppm), normalized peak 
intensity and number of hits (maximum is 4 - two in the orthogonal planes and two in 
any of the tilted planes).
The PR.list file is for internal use and contains the same information as the PR.out file, 
except the peak positions are in Hz with respect to the carrier frequency. The additional 
columns are internal scores, the projection angle used for this data set and peak positions 
in XX.pk lists.
The XX.pk lists are produced from the standard XX.ll peak lists generated by the ll2d 
command and contain the F2 peak positions in Hz relative to the carrier frequency, peak 
linewidth, the same for F1, the absolute peak intensities and some internal scoring.
The PR.more file contains additional information relative to that in PR.list. The columns 
show the peak intensities in F1, F2 and projections P1 and P2 with respect to the average 
intensity in each corresponding dimension, the same intensities relative to F1, the 
frequency deviations in F3, F1 and F2, the H-1 linewidth and its variation in Hz and 
finally F1 and F2 linewidth in Hz.  
The PR.bpa file contains the number of projected peaks at projection angles spanning 
from 0 to 90 degrees. The data from both, positive and negative angles are added 
together. After this file is accessed to find the next projection angle it is renamed with an 
index appended, increasing with each new experiment.
The PRglobals file contains a record of all the PR global variable values present at the 
start of the experiment. 
The PRmessages file contains a record of all the output messages produced by the above 
macros. These same messages are displayed in the message window of VnmrJ.
                           
20.0  4D Projection Reconstruction Experiments.

Introduction
      
A  set of of BioPack pulse sequences have been submitted by Ron Venters, Brian 
Coggins and Pei Zhou of Duke University to permit "linked" acquisition of indirect 
dimensions allowing for rapid acquisition of 4D PR experiments (JACS 127(24), 8785-
8795 (2005)). These have  angle parameters similar to the  "pra" parameter described 
above for 3D experiments (use the Experiments drop-down menu and select "Protein 
Triple-Resonance"..."4D Projection Reconstruction (TILT)" to select these experiments). 
Since there is one extra dimension there are two "angles" for converting a 4D sequence 
into a 2D version. Additionally, there are several 4D -> 3D sequences in which case only 
one angle is needed. If the value of either of these angles is zero or 90 degrees, an 
orthogonal 2D projection will be collected.  If the projection angles are between 0 and 90 
degrees, the t1, t2 and t3 evolution times are co-incremented. Because of the higher 
dimensionality, the number of tilted planes required to remove all ambiquity is typically 
larger than in the 3D versions. 

Any of the above mentioned experiments may be run simply by manually entering the 
projection angles, except that certain combinations are physically impossible. The 
permissible projection angles needed are not known in advance, but entering two angles 
will result in the automatic determination of the third angle. These experiments have 
parameter sets in which the best angle combinations have already been determined. The 
user just selects the number of tilted planes and this sets up the list of permissible  angles. 
BioPack has a dedicated interface to manage the optimal collection of these 4D PR 
experiments.

The Acquire/Acquisition page is optimized for these experiments. The box at the left 
shows the detection dimension (usually NH protons). The "PR Acquisition" boxes show 
the active number of increments and spectral window for the 2D experiment. The spectral 
windows for orthogonal planes are entered (swCa and swCb in this example) along with 
the angles.  The "Spectral width" (sw1) value is actually calculated  from the choices 
made for the individual spectral windows and for the input angles to make sure that all 
signals will appear at the correct (non-folded) positions. Thus the sw1 value will change 
for different combinations of tilt angles. 

The NH orthogonal plane is controlled by the swN parameter and the "increments in t1"
value. All of the angles and the sw1 value are set by operator choice in the "Acquisition 
Mode" section at the lower right. When one of these is selected, the values of sw1, phase, 
phase2 and the angles are set. The sequences are named PR42... or PR43...,indicating 
4D -> 2D or 4D -> 3D PR experiments.

Management of acquisition of multiple 2D experiments with different tilt angles, suitable 
for spectral reconstruction, is done via the "Proj.Reconstr." page in the "Acquire" folder 
in the VnmrJ interface. This page will be visible for any of these.

The variables visible in this interface are all "local" parameters, not "globals" as in the 
3D PR panel. These variables are created, if needed, by the  BP_PR_angles_all macro 
that runs as part of the experiment setup macro. The first experiment's nt, sw1, ni and 
angle parameters will be set when the PR queue begins. Whereas, the above 3D PR 
queueing was for multiple pulse sequences, this queueing is for different angle 
combinations for the same pulse sequence.

After specifying the sample name and storage directory, the user uses a menu to select a 
total number of tilted planes (PR_nTilts) to acquire (6,8,10,12,20,30,40 and 100 are the 
options). Then the number of transients used for the NH orthogonal plane is set. The 
number of transients (PR_ntN) should be set relative to the intrinsic sensitivity of the 
sequence specified and the concentration of the sample. The number of transients for the 
other orthogonal planes (PR_ntNorthog1, PR_ntorthog2) and all tilted plane 
(PR_ntTILT) acquisitions are set relative to the expected sensitivities. 

A button is provided ("Set for Maximum # Increments") that runs a macro (BP_PRcheck) 
to set the maximum permissible number of increments for the orthogonal and tilted 
planes. These values are placed in the entry boxes on lines 5 through 8. These maxima 
are determined by the presence or absence of a constant time evolution period (If the 
output number is 1000, there is no constant time period and the number may be set as 
desired). 

The natures of the orthogonal planes are indicated by a text message (in red) given by the 
angle name. The number of transients for each orthogonal and tilted plane is also 
enterable.

After setting these parameters, the button "Check for Maximum # Permitted Increments" 
will run a macro (BP_PRmessage) that calculates the maximum number permissible. It is 
important, of course, to check the total time with the "Show Total Time" button 
(BP_PRtime2). In this case, as opposed to the 3D case with automatic angle selection, the 
time is deterministic.

If the time is within the desired allotted time, use the "Begin" button to start acquisition 
(BP_PRstart). The data directory will be used to store the data as acquired. 2D data 
processing is provided within VnmrJ for all projection planes using the processing 
panels, but Projection Reconstruction data processing should be done with PRCALC (see 
below).

PR Parameters 

PRnTilts - Number of tilted planes to be acquired. This also specifies the number of 
angle combinations for the projection angles. These values are currently limited to 
6,8,10,12,20,30,40 and 100 and are stored as text strings in the local parameter table. The 
value is selected by menu in the Proj.Reconstr. page in the Acquire Folder.
PRntN - Number of transients to be used for the NH 2D orthogonal plane (other 
projection angle(s)= 0 or 90). 
PRntorthog1 - Number of transients to be used for the first 2D orthogonal plane 
PRntorthog2 - Number of transients to be used for the second 2D orthogonal plane 
PRntTILT - Number of transients to be used for a Tilted 2D 
PRniN - Number of increments to be used for the NH 2D orthogonal plane.
PRni2 - Number of increments to be used for the first 2D orthogonal plane.
PRni3 - Number of increments to be used for the second 2D orthogonal plane.
PRvar1 - angle variable for the first (non-NH) 2D orthogonal plane, e.g. "angle_Ca" 

PRvar2 - angle variable for the second (non-NH) 2D orthogonal plane, e.g. "angle_Co"

PR_skipPlanes - flag variable to permit skipping acquisition of orthogonal planes.


Macros 

BP_PRcheck - macro to evaluate maximum number of increments for the current pulse 
sequence. It returns four values: PR_niN, PR_ni2, PR_ni3 and PR_niTilt.

BP_PRmessage - macro to check number of increments for the current pulse sequence 
relative to the maximum possible values. 

BP_PRtime2 - macro to calculate total duration of the PR experiment.

BP_PRstart - macro to begin the acquisition. BP_PRstart(PRvar1,PRvar2) is used for 
4D->2D experiments and BP_PRstart(PRvar1) is used for 4D->3D experiments.

Projection Reconstruction using PRCALC

Projection Reconstruction software may be obtained directly from the Duke NMR group 
by using their web site (http://zhoulab.biochem.duke.edu/software/pr-calc). Their 
software (PRCALC) has been described in the literature (B.Coggins and P. Zhou, 
J.Biomolecular NMR, 34, 179-195 (2005)) and is usable via NMRpipe software 
(http://www.onemoonscientific.com). The following section gives instructions on how to 
process the VnmrJ data and do Projection Reconstruction.

Sample Data Set

A sample PR data set is provided with BioPack. It has data for 100 PR angles in a 4->2 
HACANNH experiment. The data set is also supplied with other files necessary for 
processing.

Experiement: PR42_ghacanhP
Sample: 1mM GB1 domain (54 residues)
Number of Projections: 100

The data were collected on the Duke Universtiy 800 MHz INOVA spectrometer using a 
standard room temperature triple resonance probe.   A total of 100 projection was chosen 
with nt=8 and ni = 19 in each projection for a total measurement time of 45 hours.

The fids are stored in the data subdirectory.  The nmrPipe processed data are stored in the 
pdata subdirectory.   The prnd.com macro separates out the sin and cos components of 
the tilted projections and should be executed first.  The process.com macro processes the 
data using nmrPipe.  In the pdata directory, control.com is the input file required by the 
PR-CALC reconstruction software.  

Small 4D regions around two residues have been reconstructed using the Filtered 
BackProjection (fbp) approach and are included in the pdata directory.  These regions 
have been calculated at the NH/N chemical shifts of two residues chosen from an 1H-15N 
HSQC data set.  These 4D regions are best displayed in nmrView  
(http://www.onemoonscientific.com ) with dimension X set to CA and dimension Y set to 
HA.  The i and i-1 chemical shifts are clearly visible for each residue. 

 The following commands were used to calculate these regions:

"pr-calc -in control.com -fbp -center 0.0Hz,0.0Hz,113.909ppm,9.245ppm -region 
100pct,100pct,5pts,5pts -out region2.nv"

"pr-calc -in control.com -fbp -center 0.0Hz,0.0Hz,133.192ppm,7.757ppm -region 
100pct,100pct,5pts,5pts -out region1.nv"

The full 4D data set can be reconstructed using the following command:

"pr-calc -in control.com -fbp -out hacanh_full.nv"

Although, with 64x64x64x630 resolution, this calculation takes a while and results in a 
663MB file.  It may be more convenient to calculate small 4D regions around the NH/N 
chemical shifts of each residue.



21.0 Non-Linear Sampling (NLS)
Introduction

Normal multi-dimensional data sets are collected using regular (linear) incrementation of 
(an) evolution time(s) because a "Fast Fourier Transform" algorithm is used for 
processing. Other processing methods have become available (Maximum Entropy, Multi-
Dimensional Decomposition, etc.) that are able to process non-linearly sampled data. 
This can represent a significant timesaving in acquisition if only 5-50% of the data needs 
to be sampled and the data can be accurately processed. 
The flexibility of the pulse programming language of VnmrJ has allowed a 
straightforward and generic implementation of acquisition of NLS data. In particular, the 
evolution time(s) for a specific fid are looked up from a text file, rather than being 
calculated from ni(2) and sw(2). All that is necessary is for the sequence to be modified 
to replace the internally calculated evolution time(s) with ones from a text file.
Vladislav Orekhov and Victor Jaravine (Swedish NMR Center, Gothenburg, Sweden) 
have implemented the idea and contributed scripts and macros to BioPack that convert an 
existing pulse sequence into a NLS version. BioPack has all the necessary files to make 
this process easy to use. All sequences have a "Digital Filter" page in the Acquire folder. 
This has a button to facilitate setting up an NLS experiment.
This button runs a macro that checks to see if the NLS version of the sequence is present 
as a compiled version. If it is not present, the current pulse sequence code is copied into 
the user's ~/vnmrsys/psglib under the same name, but with "_S" appended. A script is 
run to insert a couple of sections into the code and the new sequence is compiled. These 
changes do not affect the original operation of the sequence and it can be run as before by 
setting SPARSE='n' (the parameter SPARSE is created, if necessary, by the BPrtppar 
macro that runs in the experiment setup macro). The execution of the code is different for 
SPARSE='y', however, in that a text file containing the evolution times is necessary.

The macro also creates a ~/vnmrsys/templates/layout file under the new sequence name 
that has all the same files as the original sequence. Therefore, the panels visible will look
Identical.

The Acquire folder now has a "Digital Filter/NLS" page visible for the new sequence.

This page is used to set the acquisition parameters for the multi-dimensional experiment. 
The number of dimensions should be set for the total dimensionality of the experiment 
(e.g. "3" for ghn_co_S). The maximum number of increments (nimax, ni2max or 
ni3max) would be that for a normal linearly sampled data set (these determine the real 
resolution in the indirect dimensions). The "increment multipliers" (stored as ni, ni2 and 
ni3) would be the reduced number. Please note that for 3D NLS acquisition the only 
purpose of these values is to define the total number of actually acquired FID's and only 
the product of these numbers is important. For example, combinations 32, 32 and 16, 64 
give exactly the same sampling schedule.

 The "Estimated T2" should be set relative to the estimated T2's of the signals in the 
specified evolutions. This permits the software to make a more intelligent choice of 
which evolution times to select. In non constant-time evolution times, signals may go 
through a null because of an active coupling. In these cases the coupling information can 
also permit the software to make a more intelligent choice of which evolution times to 
select.

 A menu is provided to specify which evolution times have a constant-time character. 
This information is not used for acquisition, but to notify the MDD processing software 
that mirror imaging of the time domain signal is possible. 

Similarly, a menu is provided to specify if similar intensity cross-peaks are to be 
expected (cexp='y' - R-MDD processing would be used) or if the cross-peaks are of 
widely differing amplitude (cexp='n' - MDD processing would be used). The former case 
would prevail for experiments such as ghn_co, while the latter case would be appropriate 
for the NOE plane of gnoesyNhsqc. This information is later used by MDD processing 
and may have important effect on the sampling scheme. It affects the checking and 
corrections of "holes" in the sampling scheme, which are situations when a certain row or 
column in the sampling scheme matrix has no or too few data measurements. The 
uncorrected holes lead to serious problems during MDD processing. In case of cexp='y', 
the check is more relaxed, which means that data recorded with cexp='n' can be later 
processed using both cexp='n' and 'y', but data recorded with cexp='y' can only be 
processed with cexp='y'. On the other hand, cexp='n' typically requires significantly 
more data points in NLS schedule, i.e. sparse levels >=10-20%. Note that a cexp value is 
needed for each dimension, i.e. for ghn_co_S cexp='nyn' (for t1, t2 and t3). The final 
value in the cexp text string is always 'n'.

Once the parameters have been entered the "Set Sampling Schedule" button runs a script 
to generate the necessary subfiles including the text file specifying the evolution times. 
At this time information is displayable in the Text Output window. A full NLS parameter 
list is also generated in the Text Output window when the "All parameters" button is 
used.

The "Check Conditions" button runs "go('check')" to check for error conditions such as 
too many increments in an indirect dimension (normally limited in constant-time 
evolutions). The TextOutput page displays any error messages. The error condition 
checking would give the same error for the non-NLS version and its nature depends on 
how the pulse program was coded, not the NLS part of the sequence. If the number of
increments (nimax, ni2max or ni3max) in a specific evolution period is too large, reduce 
the number until no error results when using the "Check Conditions" button.

At this time the experiment can be started normally. Data will be acquired and stored as 
in any other experiment. Data may be processed normally using wft and wft1da, but note 
that the first increment is usually not for d2=0, and therefore data may be modulated. Use 
"dps" to verify the actual evolution time. While wft1da may be used to examine the entire 
data set, do not use wft2da. 2D processing will require NLS-compatible software. 

Use the macro BPsvf (normal BioPack "Save Fid" button", not the command "svf") to 
save the data. Apart from the FID, the macro also saves the sampling schedule and other 
important files.

Reference material for learning about the NLS schedule and data processing can be found 
at:

1.	Orekhov, V. Y.; Ibraghimov, I.; Billeter, M., Optimizing resolution in multidimensional 
NMR by three-way decomposition. J. Biomol. NMR 2003, 27, 165-173.
2.	Tugarinov, V.; Kay, L. E.; Ibraghimov, I.; Orekhov, V. Y., High-resolution four-dimensional 
H-1-C-13 NOE spectroscopy using methyl-TROSY, sparse data acquisition, and 
multidimensional decomposition. J. Am. Chem. Soc. 2005, 127, 2767-2775.
3.	Jaravine V, Ibraghimov I, Orekhov VY. Removal of a time barrier for high-resolution multi-
dimensional NMR spectroscopy. Nature Methods, 2006, 3: 605-607. 


NLS Parameters, Macros, Files and Commands

SPARSE is a flag used by the pulse sequence in order to run a normal linearly sampled 
('n') experiment or an NLS experiment ('y'). SPARSE is set to 'y' when using the 
button in the "Digital Filter" page.

nimax, ni2max and ni3max define final dimensions of the  spectrum  (this would be the 
numbers for the desired resolution in the linear sampling case).

ni, ni2 and ni3 affect only the number of actually recorded FIDs and consequently the 
total measurement time (use the "time" command as usual). The values are not used by 
the pulse sequence if SPARSE='y'. While ni is used for a 2D NLS experiment, only the 
product nixni2(xni3) is used for 3D (or 4D) experiments to determine the number of FIDs 
to be acquired. Therefore, specify the desired resolution by setting the nimax parameters.

There are two parameters that affect the sampling schedule:
  T2sp - estimated T2 time. Use large value in case of CT evolution (e.g. 1 second). 
  Jsp  - estimated J-coupling constant, e.g. in case of 13C evolution, e.g. in 
        non-constant time HNCA it is 35 Hz. Use Jsp=0 if the coupling is not relevant.
  
The proper value of the "cexp" parameter should be set depending on the nature of the 
sequence (see above).

The macro BP_NLSset generates the sampling schedule (via the button).

The "All Parameters" button runs the macro "dgnls" which shows parameters and
their values in the Text Output window.

Text files *.hdr_2, *.hdr_3 and *.in are automatically created in the
current experiment ( * is the pulse sequence name). These store the
sampling schedule and an input file for NLS processing.

The processing of the sparse data must be performed by using non-FT
software.


Files:
bin-
 init_SP.gawk, runspheader.sh, spheader, spheaderLNX,
 spheaderMAC, spheaderSUN, split_dims.sh

maclib-
 BP_NLSinit                 a macro to convert a pulse sequence to NLS capability
 BP_NLSset                  a macro to set up a sampling schedule
 BP_NLScheck            a macro to run go('check') for ni*max values
 BP_NLSstop               a macro to switch back to parent sequence
 BPsvf                          saves NLS text files from current exp along with fid, etc.
 BPrtppar                     creates SPARSE flag (BPrtppar is called in BioPack experiment 
                                     setup macros
 dgnls                           a macro to display NLS parameters in text window


Command Line Operation:
                        1. use experiment setup macro (e.g. ghn_co_ca)
                        2. enter BP_NLSinit
                        3. enter parameters (use dgnls to view)
                        4. enter BP_NLSset to create sampling schedule
                        5. enter BP_NLScheck to check limits on increments
                        6. acquire data with "go"
                        7. save fid with BPsvf(name)


APPENDIX:

Definitions and Descriptions of NLS Operation


Description of the algorithm for the generation of the NLS schedule 

For the case of a three-dimensional spectrum the schedule matches a two-dimensional 
probability density function for the indirect evolution dimensions. The function is defined 
on a two- dimensional grid (t1, t2) determined by spectral widths and maximal 
acquisition times  (t1max, t2max) in the two dimensions. Sampling on a grid, which we 
define as "sparse sampling", is a special case of a more general non-uniform sampling 
that allows sampling at arbitrary selected time points. The distribution is obtained as a 
product of the two envelopes, P(t1,t2) = P1(t1) x P2(t2). The envelope functions P1(t1) 
and P2(t2) are  devised to match the signal coherences in the indirect dimensions for a 
particular system  and experiment. Currently three possibilities are implemented: 

i.	mono-exponential relaxation:                    P (t1) = exp(-t/T2) 
ii.	modulation by the one-bond J-coupling:    P(t2) = cos(t pi/J) 
iii.	The J-modulation can be combined with the relaxation decay 

The transverse relaxation time T2 and value of the J coupling are parameters of the 
procedure. For a given probability distribution, we use the following procedure to 
generate the NUS schedules. First, a pair of integer indices is randomly selected that 
corresponds to the acquisition times (t1, t2). Then the pair is added to the sampling 
schedule table if the corresponding value of the probability distribution P(t1,t2) is larger 
than another randomly generated number ranging between 0  and 1; otherwise, the index 
pair is discarded. This process is repeated until the sampling table contains the requested 
number of data points. Thus, a NLS schedule is a table of evolution delays (t1, t2) 
spanning maximal acquisition times and spectral widths in the indirect dimensions. 


runspheader.sh, a csh script to generate NLS

The non-uniform sampling scheme is produced by the runspheader.sh script, which takes 
all needed parameters from an input file (sequence name appended by ".in",e.g. 
ghn_co_S.in,  present in the current experiment)

For example,         runspheader.sh ghn_co_S.in

The function of the runspheader.sh script is to call the program spheader with appropriate  
parameters. Normally, the input file is produced by a spectrometer program (e.g. 
BioPack), which also starts runspheader.sh . However the script can be run directly from 
a Unix shell window, provided the input file is prepared (see below). The script produces 
several header files with names (defined by the file parameter present in the input file) 
with extensions .hdr_X X=1-5. The file *.hdr_3 is the most relevant.  It contains "t1 t2 
[t3...]" indexes of time evolution points in the indirect spectral dimensions. If needed, the 
evolution delays can be produced by multiplying these indexes by the corresponding 
dwell times (i.e. 1/sw1).

Description of the input file format - input for runspheader.sh

The file contains lines started by keywords followed by a list of parameters values. All 
the keywords given below are mandatory. 

Below, several examples of input files are presented. The examples can be found in the 
mddnmr  software version 1.3 (Sep 2006). 

3D NOESY-HSQC 
160 x 44 complex points in 1H(NOE) x 15N dimensions. Ratio  NI/NIMAX=45/160 
gives ~ 28% sparse level 
(see example 3, azurin3dNOESY/az15n2_5%2_nohsqc_3d/az15n2.in)

file  az15n2                            this is root name for all header files
NDIM  3                                dimensionality of the experiment
seed  4321                             seed for random number generator. 
SPARSE n                             reserved parameter for spectrometer software
sptype shuffle                        reserved parameter
f180  nnn                               180 degree flag for corresponding dimension if 
                                              evolution time  is started at half a dwell time.
CT_SP nnn                            constant time flag. MUST be nnn for NOESY-HSQC
CEXP  nnn                             must be nnn for NOESY-HSQC
NIMAX 160 44 1                  final time domain dimensions (1=direct dimension)
NIMIN 0  0  0                        reserved parameter
NI    45  44 1                         the product of the numbers relative to the.
                                              NIMAX product. It determines the sparse level as 
                                              s=(NI1*NI2)/(NI1max*NI2max) 
                                              IMPORTANT NOTE: only first numbers in NIMAX and
                                              NI can be different  for NOESY-HSQC
SW 8000.0 2000 8000.0       Spectral widths for all dimensions
T2    0.05 0.1 1                     estimated T2s for indirect dimensions
Jsp   0 0 0                             one-bond coupling. 

3D HNCO 
(see example 2, ubidemo/ubi_ghnco_3d_600Y.fid/ghnco.in)

file  ubi_ghnco_3d_600Y
NDIM   3                              3 dimensions:  C' N  Hn
seed   54321
SPARSE n                            y/n toggles NUS/uniform mode
sptype shuffle                       modes of NUS - reg/shuffle/over (default is
                                             shuffle); shuffle=matched no repeats; 
                                             over=matched with repeats; reg=uniform
f180   nnn                             180 degree flag for corresponding dimension
                                             if evolution time is started at half dwell time
CT_SP  nyn                          CT evolution in 15N
CEXP   yyn                           R-MDD mode for 13C and 15N dimensions
NIMAX  64 32 1
NIMIN  0  0  0 
NI     7  32 1                          sparse level 11 percent  (7*32/(64*32))
SW     1500.0 1499.981 12001.2 
T2     0.05 1 1                       T2=50ms for 13C and 1s for 15N 
                                            (CT implies no decay in evolution) 
Jsp    0 0 0

Processing of NLS spectra using MDDNMR software

Processing of spectra recorded using NUS can be performed using mddnmr v1.3 (or 
higher). The software is available. Contact: 

Vladislav Y. Orekhov
Associate Professor
Swedish NMR Centre at Gothenburg University
Box 465, Gothenburg
SE 40530, Sweden
E-mail: orov[at]nmr.gu.se


Structure of the NLS (*hdr.3) table

The NLS table is an ASCII file, where every line contains integer increments 
corresponding to evolution times for all indirect dimensions. The number of entries in the 
table corresponds to a complete uniformly sampled experiment with dimensions NI x NI2 
[ x NI3 ...] for t1, t2 [,t3 ...]. However, values of the indexes in the table vary in the range 
from zero to NImax, NI2max,[NI3max ...], respectively. Thus, the scheme is generically 
applicable to any existing pulse sequence. Uniformly incremented indexes in the pulse 
sequence must be substituted by the values from the NLS table for every new FID. This 
means that the original values of the evolution incremental delays are not used. New 
evolution delays are produced by multiplying these indexes by corresponding dwell time 
(i.e. 1/sw1).

Implementation in BioPack

The BioPack implementation features automatic creation of a new NLS version of any 
multi-dimensional pulse sequence by use of a button in the DigitalFilter page in the 
Acquire Folder of VnmrJ. After specifying the number of increments, etc., a single button 
is used to generate all the NLS files including the table of increments (*hdr_3) via the 
"Set Sampling Schedule" button in the same page.  Acquisition is performed in the 
normal manner. Saving of the data using the BioPack macro "BPsvf" also saves the NLS 
files and a script to permit easy processing by the MDD software.
