// Copyright (C) 2015  University of Oregon
// You may distribute under the terms of either the GNU General Public
// License or the Apache License, as specified in the LICENSE file.
// For more information, see the LICENSE file.
/* hmbcHT - Gradient Selected aboslute value Hadamard HMBC experiment

    Requires a frequency list of C-13 resonances, F1.ll in the current 
    experiment. The list is generated by recording a 1D C-13 spectrum, 
    setting a proper threshold and executing the htll macro.

    parameters:
    ==========
    bw1 - excitation bandwidth. For pshape = 'gaus180' good numbers are 
          90, 45, 30 or 20 Hz.
    ni  - number of increments. Must be a power of 2. Other allowed values 
          are n*12, n*20 and n*28, where n is a power of 2.
    nimax - sets limit to ni to prevent unrealistic experiments.
    niofs - ni offset. Sets the number of increments to be omitted. Typical
            value is niofs = 1.
    pshape - shape used for Hadamard encoding, typically gaus180, square180,
             sinc180.
    bscor - Bloch-Siegert correction for Hadamard encoding, typically set 
            bscor = 'y'.
    repflg - set repflg = 'n' to suppress Pbox reports.
    ssF1 - stepsize for Hadamard encoding pulses. This parameter is adjusted
           by looking at the maximum phase increments in Hadamard enconing
           pulses, e.g. F1_2.RF. If unsure, set ssF1 = 0 to disable it.
    pwpat - CH decoupling (.RF) pulse. Use inversion pulses of 1 - 1.5 ms and
           an appropriate supercycle. The total length must be the same as  
           that of the Hadamard encoding pulse (F1_1.RF). For example, 
           with 45 ms long pulse us a 40 step supercycle (e.g. t5,m8) and
           1.125 ms long adiabatic pulse:
           >Pbox CHdec -w "wurst2i 25k/1.125m" -sucyc t5,m8 -s 5.0 -p ... -l ...       
    Hpwr - Power level for pwpat (CH decoupling).
              
	Features included:
		Randomization of Magnetization prior to relaxation delay
			with G-90-G 
			[selected by sspul flag]
		J-filter to suppress one-bond correlations
				
	Paramters:
		sspul :		y - selects magnetization randomization option
		hsglvl:		Homospoil gradient level (DAC units)
		hsgt	:	Homospoil gradient time
		gzlvl1	:	encoding Gradient level
		gt1	:	encoding gradient time
		gzlvl3	:	decoding Gradient level
		gt3	:	decoding gradient time
		gstab	:	recovery delay
                Gratio  :       encoding/decoding gradient ratio
		j1XH	:	One-bond XH coupling constant
		jnXH	:	multiple bond XH coupling constant
		pwxlvl  :	X-nucleus pulse power
		pwx	:	X-nucleus 90 deg pulse width
		d1	:	relaxation delay
		d2	:	Evolution delay

*/


#include <standard.h>

static int ph1[1] = {0};
static int ph2[1] = {0};
static int ph3[2] = {0,2};
static int ph4[1] = {0};
static int ph5[4] = {0,0,2,2};
static int ph6[4] = {0,2,2,0};

void pulsesequence()
{
  double  j1XH = getval("j1XH"),
          jnXH = getval("jnXH"),
          pwxlvl = getval("pwxlvl"),
          pwx = getval("pwx"),
          compX = getval("compX"),
          gzlvl0 = getval("gzlvl0"),
          gzlvl1 = getval("gzlvl1"),
          gzlvl2 = getval("gzlvl2"),
          gt0 = getval("gt0"),
          gt1 = getval("gt1"),
          gt2 = getval("gt2"),
          gstab = getval("gstab"),
          Gratio = getval("Gratio"),
          tau, taumb;
  char	 sspul[MAXSTR], pshape[MAXSTR];
  shape  hdx;                              /* HADAMARD stuff */

  if(j1XH < 0.1) j1XH=150.0;
  if(jnXH < 0.1) jnXH=10.0;
  
  taumb = 0.5/jnXH;
  tau = 0.5/j1XH;
  getstr("sspul",sspul),
  getstr("pwpat", pwpat);
  getstr("pshape", pshape);              /* pulse shape as in wavelib */
  setlimit("ni", getval("ni"), getval("nimax"));     /* limits max ni */

  hdx = pboxHT_F1i(pshape, pwx*compX, pwxlvl);         /* HADAMARD stuff */
  if(getval("htcal1") > 0.5)           /* enable manual power calibration */
    hdx.pwr += getval("htpwr1");
      
  settable(t1,1,ph1);
  settable(t2,1,ph2);
  settable(t3,2,ph3);
  settable(t4,1,ph4);
  settable(t5,4,ph5);
  settable(t6,4,ph6);
 
  getelem(t3,ct,v3);
  getelem(t6,ct,oph);

  initval(2.0*(double)((int)(d2*getval("sw1")+0.5)%2),v10);
  add(v3,v10,v3);
  add(oph,v10,oph);

  status(A);

    delay(5.0e-5);
    zgradpulse(gzlvl0,gt0);
    if (sspul[0] == 'y')
    {
      rgpulse(pw,zero,rof1,rof1);
      zgradpulse(gzlvl0,gt0);
    }
    

    pre_sat();
      
    if (getflag("wet"))
      wet4(zero,one);

   decoffset(dof);
   decpower(pwxlvl);
   obspower(tpwr);
   obsoffset(tof);
   delay(2.0e-5);

  status(B);

   rgpulse(pw,t1,rof1,rof2);
   zgradpulse(gzlvl1,gt1);
   delay(tau - rof2 - rof1 - 2*GRADIENT_DELAY - gt0);
   decrgpulse(pwx, t2, rof1, rof1); 
   zgradpulse(-gzlvl1,gt1);
   delay(taumb - rof1 - pwx - 2*GRADIENT_DELAY - gt0);
     
   decpower(hdx.pwr); obspower(getval("Hpwr")); 
   simshaped_pulse(pwpat, hdx.name, hdx.pw, hdx.pw, zero, zero, rof1, rof1); 
   decpower(pwxlvl); obspower(tpwr); 
      
   decrgpulse(pwx,v3,rof1,rof1);
   zgradpulse(gzlvl2,gt2);
   delay(gstab);
   rgpulse(pw*2.0,t4,rof1,rof1);
   zgradpulse(gzlvl2,gt2);
   delay(gstab);
   decrgpulse(pwx,t5,rof1,rof2);
   zgradpulse(2.0*gzlvl2/Gratio,gt2);
   decpower(dpwr);
   delay(gstab);
 
  status(C);
} 

